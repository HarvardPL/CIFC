Require Import Coq.Arith.Arith.
Require Import Coq.Bool.Bool.
Require Import Coq.Strings.String.
Require Import Coq.Arith.EqNat.
Require Import Coq.omega.Omega.
Require Import Coq.Lists.List.

Require Import SfLib.
Require Import Language.
Require Import Lemmas.
Require Import Low_eq.
Require Import Label.

Lemma simulation_L : forall ct t1 fs1 lb1 sf1 ctns_stack1 h1  t2 fs2 lb2 sf2 ctns_stack2 h2
      ctn1' ctns_stack1' h1'  ctn2' ctns_stack2' h2' φ, 
      valid_config (Config ct (Container t1 fs1 lb1 sf1) ctns_stack1 h1 ) ->
      valid_config (Config ct (Container t2 fs2 lb2 sf2) ctns_stack2 h2 ) ->
      forall T, tm_has_type ct empty_context h1 t1 T -> 
      tm_has_type ct empty_context h2 t2 T -> 
      field_wfe_heap ct h1 -> wfe_heap ct h1 ->
      (*wfe_stack_frame ct h1 sf1 -> *)
      field_wfe_heap ct h2 -> wfe_heap ct h2 ->
      (* wfe_stack_frame ct h2 sf2 -> *)
      flow_to lb1 L_Label = true ->
      flow_to lb2 L_Label = true ->
      L_equivalence_config (Config ct (Container t1 fs1 lb1 sf1) ctns_stack1 h1 )
            (Config ct (Container t2 fs2 lb2 sf2) ctns_stack2 h2)  φ ->
     Config ct (Container t1 fs1 lb1 sf1) ctns_stack1 h1 
      ==> Config ct ctn1' ctns_stack1' h1' ->
     Config ct (Container t2 fs2 lb2 sf2) ctns_stack2 h2
      ==> Config ct ctn2' ctns_stack2' h2' ->
     L_equivalence_heap h1 h2 φ ->
      exists  φ', L_equivalence_config (Config ct ctn1' ctns_stack1' h1')
            (Config ct ctn2' ctns_stack2' h2')  φ'.
 Proof with eauto. 
      intros ct t1 fs1 lb1 sf1 ctns_stack1 h1  t2 fs2 lb2 sf2 ctns_stack2 h2
      ctn1' ctns_stack1' h1'  ctn2' ctns_stack2' h2'  φ.
    
      intro H_valid1.       intro H_valid2. intro T. intro H_typing1. intro H_typing2. 
      intro H_wfe_field1. intro H_wfe_heap1.  (* intro H_wfe_sf1. *)
      intro H_wfe_field2. intro H_wfe_heap2.  
      intro H_flow1. intro H_flow2. intro H_low_eq.   intro H_reduction1. intro H_reduction2. 
      intro H_bijection.
     remember (Config ct (Container t1 fs1 lb1 sf1) ctns_stack1 h1) as config1. 
     remember (Config ct ctn1' ctns_stack1' h1') as config1'.
     generalize dependent t1. generalize dependent fs1. generalize dependent lb1. 
     generalize dependent ctns_stack1. generalize dependent h1. 

     generalize dependent t2. generalize dependent fs2. generalize dependent lb2. 
     generalize dependent ctns_stack2. generalize dependent h2. 
     generalize dependent T. generalize dependent sf1. generalize dependent sf2.

     induction H_reduction1; intros; auto; inversion Heqconfig1; inversion Heqconfig1'; subst; 
     inversion H_low_eq; subst;  try (rewrite H_flow1 in H16; inversion H16; fail);
     try (rewrite H_flow1 in H15; inversion H15; fail);  try (rewrite H_flow1 in H5; inversion H5; fail).

     Ltac solve_by_invert :=
       match goal with | H : ?T |- _
                         => solve [inversion H; subst; auto]
                          end.
     
     Ltac solve_by_invert_non_value :=
       match goal with | H : ?T |- _ =>
                         match T with
                         | value _  => solve [inversion H; subst]
                         end end.
     
     Ltac solve_by_invert_tm :=
       match goal with | H : ?T |- _ =>
                         match T with 
                         | L_equivalence_tm _ _ _ _ _ => solve [inversion H; subst; try (contradiction); solve_by_invert_revised]
                         end end. 

     Ltac solve_by_invert_ctn :=
       match goal with
       | H : L_eq_container _ _ _ _ _ |- _ =>
          solve [ inversion H; subst; 
                  try (solve_by_invert_tm; subst; intuition); try (solve_by_invert_non_value);
                  try (
                      match goal with
                      | H : L_equivalence_fs _ _ _ _ _ |- _ =>
                        solve [ inversion H; subst; 
                                match goal with
                                | H1 : L_equivalence_tm (_ hole _) _ _ _ _ |- _ =>
                                  inversion H1
                                | H1 : L_equivalence_tm (_ hole _ _) _ _ _ _ |- _ =>
                                  inversion H1
                                | H1 : L_equivalence_tm (_ _ _ hole) _ _ _ _ |- _ =>
                                  inversion H1
                                | H1 : L_equivalence_tm (_ hole ) _ _ _ _ |- _ =>
                                  inversion H1    
                                end
                              ] 
                      end);
                  try (
                      match goal with
                      | H : hole_free _ |- _ =>
                        solve [ inversion H; subst] 
                      end) 
                ]
                
       end. 

     (* var *)
- inversion H_typing1. inversion H4. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto. exists φ. auto.
  inversion H19; subst; auto. exists φ. auto. 
  inversion H17; subst; auto. intuition.
  inversion H20; subst; auto. inversion H9; subst; auto. intuition. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto.  exists φ. auto.
  inversion H20; subst; auto. inversion H9; subst; auto.  exists φ. auto.
  inversion H17; subst; auto. inversion H12.
  inversion H21; subst; auto. inversion H10; subst; auto. 
  inversion H9.  subst; auto. inversion H12. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H18; subst; auto.  
  inversion H20; subst; auto. inversion H9; subst; auto. intuition. 
  inversion H18; subst; auto.
(*
  rewrite <-H in H4. inversion H4; subst; auto.
  rewrite <- H0 in H13. inversion H13. subst; auto. 
  exists φ.
  case_eq (flow_to (join_label lo lb2) L_Label); intro.
  apply L_equivalence_config_L; auto.
  admit.
  *)
  exists φ. inversion H21. subst; auto.  inversion H9; subst; auto. 
  inversion H_bijection; subst; auto.
  apply H1 in H5; auto. inversion H5.  subst; auto.
  rewrite <- H8 in H. inversion H. subst; auto. 
  rewrite <- H11 in H4. inversion H4; subst; auto. 

  assert (flow_to (join_label lb0 lb1) L_Label = true).
  apply join_L_label_flow_to_L; auto.

  assert (flow_to (join_label lb3 lb2) L_Label = true).
  apply join_L_label_flow_to_L; auto.  
  apply L_equivalence_config_L; auto.
  destruct H24; subst; auto.
  destruct H27; subst; auto.
  destruct H27.  destruct H27.
  apply L_eq_ctn; auto.

  assert (v = null \/ exists o', v = ObjId o').
  inversion H_typing1; subst; auto.
  inversion H31; subst; auto. 
  apply field_value  with h1' o cls2 F1 lb3 fname0 ct cls' ; auto.
  
  destruct H29; subst;auto.
  assert (F1 fname0 = Some null). auto.
  apply H27 in H29. rewrite H29 in H13. inversion H13. subst; auto.
  destruct H29 as [o']. subst; auto.

  assert (v0 = null \/ exists o', v0 = ObjId o').
  inversion H_typing2; subst; auto.
  inversion H31; subst; auto. 
  apply field_value  with h2' o0 cls2 F2 lb3 fname0 ct cls' ; auto.
  destruct H29. subst; auto.  destruct H27 with fname0.
  assert (F2 fname0 = Some null). auto. apply H30 in H31.
  rewrite H31 in H0. inversion H0. destruct H29 as [o''].
  subst; auto. destruct H28 with fname0 o' o'';auto.
  rename x into hfo1. destruct H29 as [hfo2].
  apply L_equivalence_tm_eq_object; auto. apply H29. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  + inversion H17; subst; auto. exists φ. auto.
    inversion H19; subst; auto. 
  + inversion H17; subst; auto. intuition.
    inversion H21; subst; auto.
    assert (value e).
    inversion H_typing1; subst; auto.
    inversion H_typing2; subst; auto.
   
    apply  value_L_eq with v h1' h2' (classTy T0) (classTy T) ct φ; auto.
    intuition. 
  + inversion H17; subst; auto.
    intuition.
    inversion H21; subst; auto.
    inversion H11; subst; auto. intuition.
  + inversion H17; subst; auto. intuition.
    inversion H21; subst; auto. inversion H11; subst; auto.
    intuition.

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  + inversion H17; subst; auto. exists φ. auto.
    inversion H20; subst; auto.
    inversion H9; subst; auto.
  + inversion H17; subst; auto.
    inversion H21; subst; auto.
    inversion H9; subst; auto.
    inversion H23; subst; auto. inversion H2.
  + inversion H17; subst; auto.
    inversion H21; subst; auto. inversion H9; subst; auto.
    inversion H11; subst; auto.
    inversion H12.

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  + inversion H18; subst; auto. 
    inversion H21; subst; auto.
    inversion H10; subst; auto.
    inversion H23; subst; auto. inversion H.
  + inversion H18; subst; auto. exists φ. auto.
    inversion H22; subst; auto.
    inversion H10; subst; auto.
  + inversion H18; subst; auto. 
    inversion H22; subst; auto.
    inversion H10; subst; auto.
    inversion H14; subst; auto. inversion H13. 
    case_eq ( hole_free e2); intro; rewrite H1 in H2; intuition.

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  + inversion H19; subst; auto.  
    subst. inversion H21; subst; auto.
    inversion H_typing1. subst; auto.
    inversion H_typing2. subst; auto.  
    assert (value e). apply value_L_eq2 with v h1' h2' (classTy T0) (classTy T) ct φ; auto.
    contradiction.
  + inversion H19; subst; auto.   
    inversion H23; subst; auto.  exists φ. auto.
  + inversion H19; subst; auto. 
    inversion H23; subst; auto.
    inversion H_typing1. subst; auto.
    inversion H_typing2. subst; auto.  
    assert (value e2). apply value_L_eq with v0 h1' h2' (classTy arguT) (classTy arguT0) ct φ; auto. contradiction.
  + inversion H19; subst; auto.
    inversion H23; subst; auto.
    inversion H14; subst; auto.
    destruct H with e1.
    inversion H_typing1. subst; auto.
    inversion H_typing2. subst; auto.
    inversion H8; subst; auto.
    inversion H27; subst; auto.
    apply value_L_eq with (v_opa_l v0 lx) h1' h2' (OpaqueLabeledTy (classTy arguT)) (OpaqueLabeledTy (classTy arguT0)) ct φ; auto.
    intro contra. subst; auto.
    inversion H5; subst; auto. auto.

- match goal with
  | H : flow_to lb2 L_Label = false |- _
    => solve [ rewrite H_flow2 in H; inversion H
             ]
  end.            

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  + inversion H19; subst; auto. 
    inversion H21; subst; auto.
    inversion H13; subst; auto. intuition.
  + inversion H19; subst; auto. 
    inversion H23; subst; auto.
    inversion H_typing1. subst; auto.
    inversion H_typing2. subst; auto.  
    assert (value e2). apply value_L_eq2  with v h1' h2' (classTy arguT) (classTy arguT0) ct φ; auto. contradiction.
  + inversion H19; subst; auto.
    (*
    rewrite <- H6 in H. inversion H; subst; auto.
    rewrite <- H0 in H14. inversion H14; subst; auto. exists  φ. auto.
*)
    inversion H23; subst; auto.
    inversion H13; subst; auto. 

    assert (cls = cls0). apply cls_def_eq with o o0 fields lx fields0 lx0 h1' h2'  φ; auto.
    subst; auto.
    rewrite <- H0 in H14; inversion H14; subst; auto. 

    exists  φ. apply L_equivalence_config_L; auto.
    apply L_eq_ctn; auto.
    apply surface_syntax_L_equal; auto. 
    inversion H_typing1. subst; auto.
    inversion H7; subst; auto.
    destruct H29 as [F']. destruct H2 as [lo].
    rewrite H2 in H; inversion H; subst; auto.
    rewrite <- H4 in H9. inversion H9; subst; auto.
    rewrite H10 in H0. inversion H0; subst; auto.

    apply  L_equivalence_store_L ; auto.
    
    intro x. case_eq (beq_id arg_id x); intro.
    intro v1. intro. exists v0. split; auto.
    unfold sf_update. rewrite H2. auto.
    unfold sf_update in H3. rewrite H2 in H3. inversion H3. rewrite <- H7.
    auto. 

    intro v2.  intro. unfold sf_update in H3. rewrite H2 in H3. inversion H3.

    intros x v2.  intro.
    exists v. split; auto. case_eq (beq_id arg_id x); intro.
    unfold sf_update. rewrite H3. auto.
    unfold sf_update in H2. rewrite H3 in H2. inversion H2.
    unfold sf_update in H2. case_eq (beq_id arg_id x); intro.
    rewrite H3 in H2.  inversion H2; subst; auto. 
    rewrite H3 in H2. inversion H2.
    
  + inversion H19; subst; auto.
    inversion H23; subst; auto.
    
    inversion H14; subst; auto.
    inversion H1. 

-  match goal with
  | H : flow_to lb2 L_Label = false |- _
    => solve [ rewrite H_flow2 in H; inversion H
             ]
  end.  

- admit.

-  match goal with
  | H : flow_to lb2 L_Label = false |- _
    => solve [ rewrite H_flow2 in H; inversion H
             ]
  end.  
   
- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion   H_bijection; subst; auto.
  assert (lookup_heap_obj h1 (get_fresh_oid h1)  = None). 
  apply fresh_oid_heap with ct; auto.
  assert (lookup_heap_obj h2 (get_fresh_oid h2)  = None). 
  apply fresh_oid_heap with ct; auto.
  apply H1 in H6.
  apply H2 in H7.
  assert (forall a1 a2 : oid, decision.Decision (a1 = a2)). auto.
  
  exists  (bijection.extend_bijection φ (get_fresh_oid h1)  (get_fresh_oid h2) H6 H7). auto.
  apply L_equivalence_config_L; auto.
  
  subst; auto.
  inversion H17; subst; auto.
  (*
  rewrite H5 in H; inversion H; subst; auto.
*)
  inversion H27; subst; auto.
  rewrite H5 in H; inversion H; subst; auto.
  apply  L_Label_flow_to_L in H25.
  apply  L_Label_flow_to_L in H26.  rewrite <- H25 in H26.
  subst; auto.
  apply L_eq_ctn; auto. 
  apply extend_heap_preserve_L_eq_fs with ct φ H6 H7; auto.
  apply extend_heap_preserve_L_eq_store with ct φ H6 H7; auto.

  inversion H17; subst; auto.

  inversion H27; subst; auto.
  rewrite H5 in H; inversion H; subst; auto.
  apply  L_Label_flow_to_L in H25.
  apply  L_Label_flow_to_L in H26.  rewrite <- H25 in H26.
  subst; auto.
   apply extend_heap_preserve_L_eq_ctns with ct φ H6 H7; auto.

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto. 
  inversion H19; subst; auto. exists φ. auto.
  inversion H17; subst; auto. intuition.  
  inversion H19; subst; auto.
  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.  
  assert (value e). apply value_L_eq with v h1' h2' T0 T0  ct φ; auto.
  intuition. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto. 
  inversion H20; subst; auto. inversion H9; subst; auto. 
  exists φ. auto.
  inversion H17; subst; auto.
  inversion H21; subst; auto. inversion H9; subst;auto.
  inversion H3; subst; auto.
  inversion H12. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto.
  inversion H19; subst; auto.
  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.  
  assert (value e). apply value_L_eq2 with v h1' h2' T0 T0  ct φ; auto.
  intuition.
  inversion H17; subst; auto. 
  inversion H19; subst; auto. exists φ.
  apply L_equivalence_config_L; auto.
  apply L_eq_ctn; auto.
  case_eq (flow_to lo0 L_Label); intro; auto. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto.  
  inversion H19; subst; auto.  exists φ. auto.
  inversion H17; subst; auto. intuition.
  inversion H19; subst; auto.
  inversion H3; subst; auto.
  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.
  inversion H6; subst; auto.
  inversion H7; subst; auto. intuition.
  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.
  inversion H6; subst; auto.  intuition. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto.  
  inversion H20; subst; auto.  exists φ. auto.
  inversion H17; subst; auto.
  inversion H21; subst; auto. inversion H9; subst; auto.
  inversion H1; subst; auto.
  inversion H12.

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto. 
  inversion H19; subst; auto. inversion H4; subst; auto.
    inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.  
  assert (value e2).
  inversion H8; subst; auto. intuition.

  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.  
  assert (value e2). inversion H8; subst; auto. intuition. 
   
  inversion H17; subst; auto.
  (*
  case_eq (flow_to (join_label lb2 lo0) L_Label); intro;
    exists φ. auto.

  apply L_equivalence_config_H; auto.*)
  inversion H18; subst; auto.
  inversion H19; subst; auto.
  inversion H3; subst; auto.
  
  assert (flow_to (join_label lb1 lo0) L_Label = true).
  apply join_L_label_flow_to_L; auto.
  assert (flow_to (join_label lb2 lo0) L_Label = true).
  apply join_L_label_flow_to_L; auto. 
  exists φ. auto. 

  assert (flow_to (join_label lb1 lo) L_Label = false). 
  apply flow_join_label with lo lb1; auto. 
  assert (flow_to (join_label lb2 lo0) L_Label = false). 
  apply flow_join_label with lo0 lb2; auto.

  exists φ.
  apply L_equivalence_config_H; auto. 
  unfold low_component. rewrite H. rewrite H1. auto.
  apply L_equivalence_config_L; auto.
  apply L_eq_ctn; auto. apply L_equivalence_store_L; intros; inversion H2. 

  exists φ.
  inversion H19; subst; auto.
  inversion H5; subst; auto.
  assert (flow_to (join_label lb1 lo0) L_Label = true).
  apply join_L_label_flow_to_L; auto.
  assert (flow_to (join_label lb2 lo0) L_Label = true).
  apply join_L_label_flow_to_L; auto.
  auto.

  assert (flow_to (join_label lb1 lo) L_Label = false). 
  apply flow_join_label with lo lb1; auto. 
  assert (flow_to (join_label lb2 lo0) L_Label = false). 
  apply flow_join_label with lo0 lb2; auto.

  apply L_equivalence_config_H; auto.
  unfold low_component.
  rewrite H2.  rewrite H3. fold low_component.
  auto.

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto.   
  inversion H19; subst; auto.  exists φ. auto.
  
  inversion H17; subst; auto. 
  inversion H19; subst; auto.
  inversion H4; subst; auto.
  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.
  inversion H7; subst; auto. intuition. 

  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.
  inversion H7; subst; auto.  intuition. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto.  
  inversion H20; subst; auto.  exists φ. auto.
  
  inversion H17; subst; auto. 
  inversion H21; subst; auto.
  inversion H9; subst; auto.
  inversion H1; subst; auto. inversion H12.

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto. 
  inversion H19; subst; auto.
  inversion H4; subst; auto. 
  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.
  inversion H9; subst; auto. intuition.

  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.
  inversion H9; subst; auto. intuition.

  inversion H17; subst; auto.

  inversion H19; subst; auto.
  inversion H4; subst; auto.
  
  exists φ. auto.
  apply H_Label_not_flow_to_L in H10. 
  apply H_Label_not_flow_to_L in H11. subst; auto. 
  exists φ. auto.

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto.  
  inversion H19; subst; auto.  exists φ. auto.
  
  inversion H17; subst; auto. 
  inversion H19; subst; auto.
  inversion H3; subst; auto.
  inversion H_typing1. subst; auto.
  inversion H6; subst; auto. intuition.

  inversion H_typing1. subst; auto.
  inversion H6; subst; auto. intuition.

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto.  
  inversion H20; subst; auto.  exists φ. auto.
  
  inversion H17; subst; auto. 
  inversion H21; subst; auto.
  inversion H9; subst; auto.
  inversion H1; subst; auto. inversion H12. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto. 
  inversion H19; subst; auto.
  inversion H4; subst; auto.
  inversion H_typing2. subst; auto.
  inversion H7; subst; auto. intuition.

  inversion H_typing2. subst; auto.
  inversion H7; subst; auto. intuition.


  inversion H17; subst; auto.

  inversion H19; subst; auto.
  inversion H3; subst; auto. 
 
  assert (flow_to (join_label lb1 lo0) L_Label = true).
  apply join_L_label_flow_to_L; auto.
  assert (flow_to (join_label lb2 lo0) L_Label = true).
  apply join_L_label_flow_to_L; auto.
  exists φ. auto.

  assert (flow_to (join_label lb1 lo) L_Label = false). 
  apply flow_join_label with lo lb1; auto. 
  assert (flow_to (join_label lb2 lo0) L_Label = false). 
  apply flow_join_label with lo0 lb2; auto.

  exists φ. 
  apply L_equivalence_config_H; auto.
  destruct ctns_stack1'; inversion H18; subst; auto;
    unfold low_component; rewrite H; rewrite H1; auto.
  apply L_equivalence_config_L; auto.
  apply L_eq_ctn; auto.
  apply L_equivalence_store_L; auto.
  intros. inversion H2. intros. inversion H2. 

- inversion H_typing1. inversion H2. 
  
- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto.  
  inversion H20; subst; auto.
  inversion H9; subst; auto.  exists φ. auto.

  inversion H17; subst; auto.

  inversion H21; subst; auto.
  inversion H9; subst; auto.
  inversion H3; subst; auto. inversion H12. 

- inversion H_typing1. inversion H2. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto.   
  inversion H19; subst; auto.   exists φ. auto.
  
  inversion H17; subst; auto. 
  inversion H21; subst; auto.

  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.
  assert (value e). apply value_L_eq with  v h1' h2' (classTy clsT) (classTy clsT0) ct φ; auto.
  intuition.

  inversion H17; subst; auto. intuition.
  inversion H21; subst; auto.
  inversion H11. subst; auto. intuition.

  inversion H17; subst; auto. intuition.
  inversion H21; subst; auto.
  inversion H11; subst; auto. intuition. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto.  
  inversion H20; subst; auto.
  inversion H9; subst; auto. exists φ. auto.
  
  inversion H17; subst; auto. 
  inversion H21; subst; auto.
  inversion H9; subst; auto.
  inversion H23; subst; auto. inversion H12.

  inversion H17; subst; auto. 
  inversion H21; subst; auto. inversion H9; subst; auto.
  inversion H4; subst; auto. inversion H12. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H19; subst; auto. 
  inversion H21; subst; auto.  
  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.
  assert (value e). apply value_L_eq2 with v h1' h2' (classTy clsT) (classTy clsT0) ct φ; auto.
  intuition.

  inversion H19; subst; auto.
  inversion H23; subst; auto. exists φ. auto.

  inversion H19; subst; auto. intuition. 
  inversion H23. subst; auto.

  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.
  assert (value e2). apply value_L_eq with v0 h1' h2' (classTy cls') (classTy cls'0) ct φ; auto. intuition.

  inversion H19; subst; auto.
  destruct H with  (v_opa_l v0 lx); auto.
  intro contra. inversion contra. 

  inversion H23; subst; auto. 
  inversion H26; subst; auto.
  inversion H5; subst; auto.

  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.
  inversion H31; subst; auto.
  inversion H14; subst; auto.
  inversion H27; subst; auto.
  inversion H28; subst; auto.
  destruct H with (v_opa_l e0 lx); auto.
  intro contra. inversion contra. 

  inversion H26; subst; auto.
  inversion H6; subst; auto.

  inversion H_typing1. subst; auto.
  inversion H30; subst; auto.
  inversion H14; subst; auto.
  destruct H with (v_opa_l e0 lx); auto.
  intro contra. inversion contra.

  inversion H_typing1. subst; auto.
  inversion H30; subst; auto.
  inversion H14; subst; auto.
  destruct H with (v_opa_l e0 l1); auto.
  intro contra. inversion contra. 
  
-  match goal with
  | H : flow_to lb2 L_Label = false |- _
    => solve [ rewrite H_flow2 in H; inversion H
             ]
  end.  

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H18; subst; auto.
  
  inversion H21; subst; auto.
  inversion H10; subst; auto.
  inversion H23; subst; auto.  inversion H0.

  inversion H18; subst; auto. 
  inversion H22; subst; auto.
  inversion H10; subst; auto.  exists φ. auto.

  inversion H18; subst; auto.
  
  inversion H22; subst; auto.
  inversion H10; subst; auto.
  inversion H24; subst; auto.
  inversion H13.
  case_eq (hole_free e2); intro; rewrite H1 in H2; inversion H2.

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H19; subst; auto. 
  inversion H21; subst; auto.
  inversion H13; subst; auto.  intuition.
  inversion H19; subst; auto. intuition.

  inversion H23; subst; auto.
  inversion H_typing1. subst; auto.
  inversion H_typing2. subst; auto.
  assert (value e2). apply value_L_eq2 with v h1' h2' (classTy cls') (classTy cls'0) ct φ; auto. intuition.

  inversion H19; subst; auto. 
  inversion H23; subst; auto. exists φ. auto.

  inversion H19; subst; auto. 
  inversion H23; subst.
  inversion H26; subst; auto. inversion H3. 

-  match goal with
  | H : flow_to lb2 L_Label = false |- _
    => solve [ rewrite H_flow2 in H; inversion H
             ]
  end. 

  
- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H19; subst; auto. intuition.
  inversion H21; subst; auto.
  inversion H24; subst; auto.
  inversion H13; subst; auto. intuition. 
  
  inversion H19; subst; auto.
  destruct H5 with (v_opa_l v lx); auto.
  intro contra. inversion contra. 

  inversion H23; subst; auto.
  inversion H26; subst; auto.
  inversion H2; subst; auto. 

  inversion H_typing1; subst; auto. 
  inversion H_typing2; subst; auto.
  inversion H27; subst; auto.
  inversion H31; subst; auto.
  assert (value (v_opa_l e2 lx)). apply value_L_eq2 with (v_opa_l v lx) h1 h2' (OpaqueLabeledTy (classTy cls')) (OpaqueLabeledTy (classTy cls'0)) ct φ; auto.
  destruct H5 with  (v_opa_l e2 lx); auto.
  intro contra. inversion contra. 

  inversion H26; subst; auto.
  inversion H_typing1; subst; auto. 
  inversion H_typing2; subst; auto.
  inversion H28; subst; auto.
  inversion H32; subst; auto.
  assert (value (v_opa_l e2 l2)). apply value_L_eq2 with (v_opa_l v lx) h1 h2' (OpaqueLabeledTy (classTy cls')) (OpaqueLabeledTy (classTy cls'0)) ct φ; auto.
  destruct H5 with  (v_opa_l e2 l2); auto.
  intro contra. inversion contra. 

  inversion H19; subst; auto.

  inversion H23; subst; auto.
  inversion H26; subst; auto. inversion H21. 

  inversion H19; subst; auto.
  inversion H23; subst; auto.
  inversion H13; subst; auto.
  inversion H26; subst; auto. 

  Lemma 

  
  
-  match goal with
  | H : flow_to lb2 L_Label = false |- _
    => solve [ rewrite H_flow2 in H; inversion H
             ]
  end. 

  
- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto. 
  inversion H19; subst; auto. exists φ. auto.
  
  inversion H17; subst; auto. 
  inversion H14; subst; auto. 
  inversion H10; subst; auto. intuition. 

  inversion H17; subst; auto. 
  inversion H14; subst; auto. 
  inversion H10; subst; auto. intuition. 


  

(*
  
Lemma field_value_two_cases : forall (sf:stack_frame) fname,
    (exists v, sf fname = Some v) \/
    sf fname = None.
Proof with eauto.
  intros.
  induction sf. left; exists a. auto.
  right. auto. 
Qed. Hint Resolve field_value_two_cases.

Lemma L_eq_unique : forall v v2 v2' h1 h2 φ,
    L_equivalence_tm v h1 v2 h2 φ ->
    L_equivalence_tm v h1 v2' h2 φ ->
    v2 = v2'.
Proof with eauto.
  intros.
  generalize dependent v2. generalize dependent  v2'.  
  induction v; intros; try (inversion H; inversion H0; subst; auto; fail).
- inversion H0. inversion H. subst; auto.
  assert (e2 = e3). apply IHv; auto. rewrite H1. auto. 
- inversion H0. inversion H. subst; auto.
  assert (e2 = e3). apply IHv1; auto.
  assert (a3 = a2). apply IHv2; auto.
  rewrite H1. rewrite H2. auto.
- inversion H0. inversion H. subst; auto.
  assert (e2 = e3). apply IHv; auto. rewrite H1. auto.
- inversion H0. inversion H. subst; auto.
  assert (e2 = e3). apply IHv; auto. rewrite H1. auto.   
- inversion H0. inversion H. subst; auto.
  assert (e2 = e3). apply IHv; auto. rewrite H1. auto. 
- inversion H0. inversion H. subst; auto.
  assert (e2 = e3). apply IHv; auto. rewrite H1. auto.   
- inversion H0. inversion H. subst; auto.
  assert (e2 = e3). apply IHv; auto. rewrite H1. auto.
- inversion H0. inversion H. subst; auto.
  assert (e2 = e3). apply IHv1; auto.
  assert (e2'0 = e2'). apply IHv2; auto.
  rewrite H1. rewrite H2. auto.
- inversion H0. inversion H. subst; auto.
  assert (s1'0 = s1'). apply IHv1; auto. rewrite H1. auto. 
  assert (s2'0 = s2'). apply IHv2; auto. rewrite H2. auto. 
- inversion H0. inversion H. subst; auto.
  assert (s1'0 = s1'). apply IHv1; auto. rewrite H1. auto. 
  assert (s2'0 = s2'). apply IHv2; auto. rewrite H2. auto.
- inversion H0. inversion H. subst; auto.
  rewrite H8 in H2. inversion H2. auto. 
- inversion H0; inversion H; subst; auto.
  assert (e2 = e3). apply IHv; auto. rewrite H1. auto.
  rewrite H3 in H11. inversion H11.
  rewrite H3 in H11. inversion H11.
  admit. 


  
  
  
Lemma sf_eq : forall id0 id3 (sf1:stack_frame) (sf2:stack_frame) h1 h2 φ, 
    ( forall x v1, sf1 x = Some v1 -> exists v2 : tm,
        sf2 x = Some v2 /\ L_equivalence_tm v1 h1 v2 h2 φ) ->
    (forall x v2, sf2 x = Some v2 -> exists o1 : tm,
          sf1 x = Some o1 /\ L_equivalence_tm o1 h1 v2 h2 φ) ->
      sf1 id0 = sf1 id3 ->
      L_equivalence_heap h1 h2 φ ->
      sf2 id0 = sf2 id3.
Proof with eauto.
  intros. pose proof (field_value_two_cases sf1 id0); auto.
  destruct H3.  destruct H3 as [v].
  assert (exists v2, sf2 id0 = Some v2 /\ L_equivalence_tm v h1 v2 h2 φ).
  apply H. auto.
  destruct H4 as [v2]. destruct H4.
  assert (sf1 id3 = Some v). rewrite <-H1. auto.
  apply H in H6.
  destruct H6 as [v2']. destruct H6.
  

  

  pose proof (field_value_two_cases sf2 id0); auto.
  destruct H4. destruct H4 as [v0].
  apply H0 in H4. destruct H4 as [o1]. destruct H4.
  rewrite H4 in H3; inversion H3.
  assert (sf1 id3 = None ). rewrite <- H1; auto.
  pose proof (field_value_two_cases sf2 id3); auto.
  destruct H6.  destruct H6 as [v']. apply H0 in H6.
  destruct H6. destruct H6. rewrite H6 in H5. inversion H5.
  rewrite H4. rewrite H6; auto. 
Qed.   
  *)

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto.
  inversion H20; subst; auto.
  inversion H9; subst; auto. exists φ. auto.

  
  inversion H17; subst; auto.
  inversion H21; subst; auto.  
  inversion H9; subst; auto.
  inversion H4; subst; auto.
  inversion H12. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H16; subst; auto.
  inversion H18; subst; auto.
  inversion H10; subst; auto. intuition. 

  inversion H16; subst; auto.
  inversion H13; subst; auto.
  
  exists φ. auto.
  
- match goal with
  | H : flow_to lb2 L_Label = false |- _
    => solve [ rewrite H_flow2 in H; inversion H
             ]
  end. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H16; subst; auto.
  inversion H18; subst; auto.
  inversion H10; subst; auto. intuition. 

  inversion H16; subst; auto.
  inversion H13; subst; auto. 
  exists φ. auto.


- match goal with
  | H : flow_to lb2 L_Label = false |- _
    => solve [ rewrite H_flow2 in H; inversion H
             ]
  end. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
   inversion H16; subst; auto.  
  inversion H13; subst; auto.  exists φ. auto.

-  match goal with
   | H : flow_to lb2 L_Label = false |- _
    => solve [ rewrite H_flow2 in H; inversion H
             ]
  end. 

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H16; subst; auto.  
  inversion H18; subst; auto.  exists φ. auto. 

-  match goal with
  | H : flow_to lb2 L_Label = false |- _
    => solve [ rewrite H_flow2 in H; inversion H
             ]
   end.

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn; fail).
  try (inversion H18; subst; auto;  inversion H0;
  inversion H21; subst; auto;
  inversion H11; subst; auto;
  inversion H10; subst; auto;
  inversion H0).

  inversion H18; subst; auto.
  inversion H21; subst; auto.
  inversion H10; subst; auto.
  inversion H12; subst; auto.
  inversion H0.

  inversion H18; subst; auto.
  inversion H22; subst; auto.
  inversion H10; subst; auto.
  inversion H14; subst; auto.
  inversion H0. 
  case_eq ( hole_free e1 ); intro; rewrite H1 in H2; intuition.

  inversion H18; subst; auto.
  inversion H21; subst; auto.
  inversion H10; subst; auto.
  inversion H6; subst; auto.
  inversion H0.

    inversion H18; subst; auto.
  inversion H21; subst; auto.
  inversion H10; subst; auto.
  inversion H5; subst; auto.
  inversion H0.

  inversion H18; subst; auto.

  inversion H21; subst; auto.
  inversion H10; subst; auto.
  inversion H5; subst; auto.
  inversion H0.
  
  inversion H18; subst; auto.
  inversion H21; subst; auto.
  inversion H10; subst; auto.
  inversion H5; subst; auto.
  inversion H0.

  inversion H18; subst; auto.
  inversion H21; subst; auto.
  inversion H10; subst; auto.
  inversion H6; subst; auto.
  inversion H0.

  inversion H18; subst; auto.
  inversion H21; subst; auto.
  inversion H10; subst; auto.
  inversion H7; subst; auto.
  inversion H0.
  
  inversion H18; subst; auto.
  inversion H22; subst; auto.
  inversion H10; subst; auto.
  inversion H24; subst; auto.
  inversion H0. 
  case_eq ( hole_free e1 ); intro; rewrite H1 in H2; intuition.

  inversion H18; subst; auto.
  inversion H21; subst; auto.
  inversion H10; subst; auto.
  inversion H7; subst; auto. 
  inversion H0. 
  
  inversion H18; subst; auto.
  inversion H22; subst; auto.
  exists φ. auto.
  

- inversion H_reduction2; subst; auto; try (solve_by_invert_ctn).
  inversion H17; subst; auto.
  inversion H18; subst; auto.
  inversion H9; subst; auto. 
  exists φ.
  apply  L_equivalence_config_L; auto.
  apply L_eq_ctn; auto. auto.
  
  apply L_Label_flow_to_L in H13.
  apply L_Label_flow_to_L in H14.
  rewrite <- H24 in H25. subst; auto.
Qed. 