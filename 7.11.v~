Require Import Coq.Arith.Arith.
Require Import Coq.Bool.Bool.
Require Import Coq.Strings.String.
Require Import Coq.Arith.EqNat.
Require Import Coq.omega.Omega.
Require Import Coq.Lists.List.
Require Import Language.
Require Import Lemmas.
Require Import Low_eq.
Require Import Label.
Require Import simulation_full.


Lemma typed_value_is_wfe_stack_val : forall h v T ct gamma, 
    tm_has_type ct gamma h v T ->
    value v ->
    wfe_stack_val ct h v.
Proof with eauto.
      intros.
      generalize dependent T. 
      induction H0; subst; auto.
      intros.
      inversion H; subst; auto.
      destruct H6 as [F0].
      destruct H0 as [lo0].
      destruct H2 as [field_defs].
      destruct H2 as [method_defs].
      subst; auto. 
      apply stack_val_object with cls_name F0 lo0 field_defs method_defs; auto.

      intros.
      inversion H; subst; auto.
      apply stack_val_labeled; auto.
      apply IHvalue with T0; auto.

      intros. inversion H; subst; auto.
      apply stack_val_opa_labeled; auto.
      apply IHvalue with T0; auto.
Qed. Hint Resolve typed_value_is_wfe_stack_val.


Lemma hole_free_if : forall t1 t2,
    (if hole_free t1 then hole_free t2 else false)
    = true
    -> hole_free t1 = true /\ hole_free t2 = true.
Proof.
      intros.
      case_eq (hole_free t1).
      intro. case_eq (hole_free t2). intro. auto.
      intro. rewrite H0 in H. rewrite H1 in H. intuition. intro. rewrite H0 in H. intuition.
Qed. Hint Resolve hole_free_if.

Lemma hole_free_if_triple : forall guard s1 s2,
    (if hole_free guard then if hole_free s1 then hole_free s2 else false else false) = true
    -> hole_free guard = true /\ hole_free s1 = true /\ hole_free s2 = true.
Proof with eauto.
  intros.
  case_eq (hole_free guard); intro.
  rewrite H0 in H.
  apply hole_free_if in H.
  destruct H. auto.
  rewrite H0 in H. intuition. 
Qed.
Hint Resolve hole_free_if_triple.


Lemma expand_heap_preserve_wfe_stack_val : forall v h ct ho,
         value v -> wfe_heap ct h ->
         wfe_stack_val ct h v ->
         wfe_stack_val ct (add_heap_obj h (get_fresh_oid h) ho) v.
Proof with eauto.
       intros.
       induction H; inversion H1; subst; auto.
        apply stack_val_object with cls_name F lo
                                   field_defs  method_defs; auto.
       apply extend_heap_lookup_eq; auto.
       apply lookup_extend_heap_fresh_oid with ct (Heap_OBJ (class_def cls_name field_defs method_defs) F lo); auto.
Qed. Hint Resolve expand_heap_preserve_wfe_stack_val.
     

Lemma expand_heap_preserve_valid_ctn : forall ctn ho h ct,
         wfe_heap ct h ->
         valid_ctn ct ctn h ->
         valid_ctn ct ctn (add_heap_obj h (get_fresh_oid h) ho).
Proof with eauto.
       intros.
       inversion H0; subst; auto.
       apply valid_container; auto.
       inversion H5; subst; auto.
       apply stack_frame_wfe; auto.
       intros. destruct H6 with x v;auto.
Qed. Hint Resolve expand_heap_preserve_valid_ctn.


Lemma expand_heap_preserve_valid_ctns : forall ctns ho h ct,
         wfe_heap ct h ->
         valid_ctns ct ctns h ->
         valid_ctns ct ctns (add_heap_obj h (get_fresh_oid h) ho).
Proof with eauto.
       intros. induction ctns. auto.
       destruct a. auto.
       inversion H0; subst; auto.
Qed. Hint Resolve  expand_heap_preserve_valid_ctns.


Lemma update_heap_preserve_wfe_stack_val : forall o v h ct F f cls lo v0,
         value v0 -> wfe_heap ct h ->
         wfe_stack_val ct h v0 ->
         Some (Heap_OBJ cls F lo) = lookup_heap_obj h o ->
         wfe_stack_val ct (update_heap_obj h o (Heap_OBJ cls (fields_update F f v) lo)) v0.
Proof with eauto.
       intros.
       induction H; inversion H1; subst; auto.
       case_eq (beq_oid o0 o); intro.
       apply beq_oid_equal in H. subst; auto. 
       assert (Some (Heap_OBJ cls (fields_update F f v) lo) =
                     lookup_heap_obj
                       (update_heap_obj h o (Heap_OBJ cls (fields_update F f v) lo)) o).
       apply lookup_updated with h (Heap_OBJ cls F lo); auto.       
       apply stack_val_object with cls_name (fields_update F f v) lo
                                   field_defs  method_defs; auto.
       rewrite <- H2 in H3; inversion H3; subst; auto.
       inversion H1; subst; auto.
       assert (Some (Heap_OBJ (class_def cls_name0 field_defs0 method_defs0) F1 lo1) =
                     lookup_heap_obj
                       (update_heap_obj h o (Heap_OBJ cls (fields_update F f v) lo)) o0).
       apply lookup_updated_not_affected with o (Heap_OBJ cls (fields_update F f v) lo) h; auto. intro contra. rewrite contra in H.
       pose proof (beq_oid_same o). try (inconsist).
       apply stack_val_object with cls_name0 F1 lo1
                                   field_defs0  method_defs0; auto.
Qed. Hint Resolve update_heap_preserve_wfe_stack_val.

Lemma update_heap_preserve_valid_ctn  : forall  o v h ct F f cls lo ctn,
    wfe_heap ct h ->
    valid_ctn ct ctn h ->
    Some (Heap_OBJ cls F lo) = lookup_heap_obj h o ->
    valid_ctn ct ctn (update_heap_obj h o (Heap_OBJ cls (fields_update F f v) lo)).
Proof with eauto.
  intros.
  inversion H0; subst; auto.
  apply valid_container; auto.
  apply stack_frame_wfe; auto.
  intros.
  split; auto.
  inversion H6; subst; auto.
  destruct H8 with x v0; auto.
  apply update_heap_preserve_wfe_stack_val; auto.
  inversion H6; subst; auto.
  destruct H8 with x v0; auto.
  inversion H6; subst; auto.
  destruct H8 with x v0; auto. 
Qed. Hint Resolve  update_heap_preserve_valid_ctn.


Lemma update_heap_preserve_valid_ctns : forall  o v h ct F f cls lo ctns,
    wfe_heap ct h ->
    valid_ctns ct ctns h ->
    Some (Heap_OBJ cls F lo) = lookup_heap_obj h o ->
    valid_ctns ct ctns (update_heap_obj h o (Heap_OBJ cls (fields_update F f v) lo)).
Proof with eauto.
       intros. induction ctns. auto.
       destruct a. auto.
       inversion H0; subst; auto.
Qed. Hint Resolve  update_heap_preserve_valid_ctns.



(*
Lemma expand_heap_preserve_valid_ctns_wfe : forall ctns ho h ct,
         wfe_heap ct h ->
         wfe_ctn_list ct h ctns ->
         wfe_ctn_list ct (add_heap_obj h (get_fresh_oid h) ho) ctns.
Proof with eauto.
        intros.
        
        induction ctns; auto.
        apply wfe_ctns_nil; auto.
        inversion H0; subst; auto. 
        apply wfe_ctns_list with  t fs lb sf ctns'; auto.
        inversion H1; subst; auto.
Qed. Hint Resolve expand_heap_preserve_valid_ctns_wfe.
  *)  
Lemma valid_config_preservation : forall T ct
                                          ctn ctns h
                                          ctn' ctns' h',
    config_has_type ct empty_context (Config ct ctn ctns h) T ->
    valid_config (Config ct  ctn ctns h) ->
    Config ct ctn ctns h
           ==> Config ct ctn' ctns' h' ->
    valid_config (Config ct ctn' ctns' h').
Proof with eauto.
  intros T ct ctn ctns h ctn' ctns' h'.
  intro H_typing. 
  intro H_valid.
  intro H_reduction.
  remember (Config ct ctn ctns h) as config.
  remember (Config ct ctn' ctns' h') as config'.
  generalize dependent ctn. generalize dependent ctn'.
  generalize dependent T. generalize dependent h.
  generalize dependent h'.
  generalize dependent ctns. 
  generalize dependent ctns'.
  induction H_reduction; intros;
    inversion   Heqconfig'; inversion  Heqconfig;
      inversion H_valid; subst; auto;        try
      (match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
      end;
        subst; auto;
    apply valid_conf; auto;
    apply valid_container; auto;
    try (apply valid_fs_list; auto;
      intro contra; inversion contra);
    try (
        match goal with
        | H :  valid_syntax (_ _) |- _
          => inversion H; subst; auto
        | H :  valid_syntax (_ _ _) |- _
          => inversion H; subst; auto
        | H :  valid_syntax (_ _ _ _) |- _
          => inversion H; subst; auto
        end; auto);
      intros; intro contra; inversion contra; fail);
    try (apply valid_conf; auto;
    match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
    end;
    apply valid_container; auto;
    match goal with
    | H : valid_fs _ |- _
      => inversion H; subst; auto 
    end;
    match goal with
    | H : valid_fs _ |- _
      => inversion H; subst; auto 
    end;
    inversion H3; auto; 
    intros;
    intro contra; inversion contra; 
    subst; auto; fail).  
  
  
  - inversion H16; subst; auto.
    inversion H11; subst; auto.
    destruct H0 with id v; auto.



  - apply config_typing_lead_to_tm_typing in H_typing.
    destruct H_typing as [T'].
    destruct H1 as [gamma].
    inversion H1; subst; auto. 
    assert (v = null \/ exists o', v = ObjId o').
    apply field_value with h0 o cls F lo fname ct cls' gamma; auto.
    apply valid_conf; auto;
    match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
    end.
    apply valid_container; auto.
    destruct H2; subst; auto.
    destruct H2 as [o']. subst; auto.

    destruct H2; subst; auto.
    destruct H2 as [o']. subst; auto.


    
  - apply valid_conf; auto;
    match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
    end;
    match goal with
    | H :  valid_fs _  |- _
      => inversion H; subst; auto 
    end;
    match goal with
    | H :  hole_free  _ = true |- _
      => inversion H; subst; auto;
           match goal with
           | H : (if hole_free _ then hole_free _ else false) = true |- _
             => apply hole_free_if in H; destruct H
           end
    end;
    try (apply valid_container; auto);
      try (apply valid_fs_list; auto;
          intro contra; inversion contra; fail);
    try (    match goal with
    | H :  valid_syntax (_ _ _) |- _
      => inversion H; subst; auto
    | H :  valid_syntax (_ _ _ _) |- _
      => inversion H; subst; auto 
    end; auto; 
    intros; 
    intro contra; inversion contra);
    try (apply valid_fs_list; auto);
    try (intro contra; inversion contra);
    try (
        match goal with
    | H :  valid_syntax (_ _ _) |- _
      => inversion H; subst; auto
    | H :  valid_syntax (_ _ _ _) |- _
      => inversion H; subst; auto
        end; auto); 
    match goal with
    | H :  hole_free _ = true |- _
      => rewrite H; auto;
           try (
               match goal with
               | H1 :  hole_free _ = true |- _
                 => rewrite H1; auto
               end
             )
    end;
    try (
    match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
    end;
    apply valid_conf; auto;
    apply valid_container; auto;
    try (apply valid_fs_list; auto);
    try (intro contra; inversion contra);
         try (
        match goal with
    | H :  valid_syntax (_ _ _) |- _
      => inversion H; subst; auto
    | H :  valid_syntax (_ _ _ _) |- _
      => inversion H; subst; auto
        end; auto); 
         try (intro contra0;
              inversion contra0); fail).


  - inversion H16; subst; auto.
    inversion H4; subst; auto.
    apply valid_conf; auto.
    apply valid_container; auto.
    inversion H2; subst; auto.
    intros. intro contra.
    rewrite contra in H3; inversion H3; intuition.
    intros. intro contra.
    rewrite contra in H3; inversion H3; intuition.
    inversion H2; subst; auto.
    inversion H12. try (
    apply surface_syntax_is_hole_free in H1;
    unfold hole_free; fold hole_free;
    rewrite H17; rewrite H1; auto).
    inversion H12. inversion H1. inversion H12. 

  - inversion H17; subst; auto.
    inversion H5; subst; auto.
    apply valid_conf; auto.
    apply valid_container; auto.
    inversion H5; subst; auto.
    intros. intro contra.
    rewrite contra in H4; inversion H4; intuition.
    intros. intro contra.
    rewrite contra in H4; inversion H4; intuition.
    unfold hole_free; fold hole_free.
    apply value_is_hole_free in H.
    apply value_is_hole_free in H0.
    rewrite H. rewrite H0. auto.


  - inversion H18; subst; auto.
    apply valid_conf; auto.
    apply valid_container; auto.
    apply valid_fs_list; auto.
    intro contra. inversion contra. 
    intro contra. inversion contra.
    inversion H9; subst; auto.
    intros. intro contra.
    inversion contra.
    intros. intro contra.
    inversion contra.
    inversion H19.
    apply hole_free_if in H3.
    destruct H3. rewrite H2.  auto.

  - inversion H20; subst; auto.
    apply config_typing_lead_to_tm_typing in H_typing.
    destruct H_typing as [T'].
    destruct H3 as [gamma].
    inversion H3; subst; auto.
    inversion H8; subst; auto.
    destruct H26 as [F0].
    destruct H4 as [lo0].
    rewrite H4 in H; inversion H; subst; auto.
    rewrite <- H6 in H15. inversion H15; subst; auto.
    rewrite H16 in H0; inversion H0; subst; auto.
    apply valid_conf; auto.
    apply valid_container; auto.
    intros. intro contra. inversion contra.
    intros. intro contra. inversion contra.
    apply stack_frame_wfe; auto.
    intros.
    case_eq (beq_id arg_id0 x);intro.
    unfold sf_update in H5. rewrite H18 in H5.
    inversion H5; subst; auto.
    split; auto.
    induction H1; inversion H11; subst; auto.
    destruct H32 as [F'].
    destruct H1 as [lo'].
    destruct H31 as [field_defs].
    destruct H19 as [method_defs].
    subst; auto. 
    apply stack_val_object with arguT F' lo'
                                field_defs method_defs; auto.
    unfold sf_update in H5. rewrite H18 in H5.
    inversion H5.

  - inversion H21; subst; auto.
    apply config_typing_lead_to_tm_typing in H_typing.
    destruct H_typing as [T'].
    destruct H0 as [gamma].
    inversion H0; subst; auto.
    inversion H8; subst; auto.
    destruct H26 as [F0].
    destruct H1 as [lo0].
    rewrite H1 in H; inversion H; subst; auto.
    rewrite <- H6 in H15; inversion H15; subst; auto.
    rewrite H16 in H4; inversion H4; subst; auto.
    apply valid_conf; auto.
    apply valid_container; auto.
    intros. intro contra. inversion contra.
    intros. intro contra. inversion contra.
    apply stack_frame_wfe; auto.
    intros.
    
    case_eq (beq_id arg_id0 x);intro.
    unfold sf_update in H5. rewrite H17 in H5.
    inversion H5; subst; auto.
    split; auto. 

    
    inversion H11; subst; auto.
    inversion H20; subst; auto.
    induction H35; inversion H37; subst; auto. 
    destruct H29 as [F'].
    destruct H29 as [lo'].
    destruct H26 as [field_defs].
    destruct H26 as [method_defs].
    subst; auto. 
    apply stack_val_object with cls_name F' lo'
                                field_defs method_defs; auto.
    eauto using typed_value_is_wfe_stack_val. 
    eauto using typed_value_is_wfe_stack_val. 
    
    unfold sf_update in H5. rewrite H17 in H5.
    inversion H5.

    
   - inversion H20; subst; auto.
     apply valid_conf; auto.
     auto. auto.
     apply  extend_heap_preserve_order with h0 (get_fresh_oid h0)
                                            cls_name
                                            field_defs
                                            method_defs lb; auto.
     apply fresh_oid_heap with ct ; auto.
     apply extend_heap_preserve_field_wfe with h0 (get_fresh_oid h0)
                                            cls_name
                                            field_defs
                                            method_defs lb; auto.
     apply fresh_oid_heap with ct ; auto.
      
   -  apply valid_conf; auto;
    match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
    end.
      apply config_typing_lead_to_tm_typing in H_typing.
    destruct H_typing as [T'].
    destruct H0 as [gamma].
    inversion H0; subst; auto.
    match goal with
    | H :  valid_fs _  |- _
      => inversion H; subst; auto 
    end;    
    apply valid_container; auto;
      try (apply valid_fs_list; auto;
          intro contra; inversion contra; fail); 
    try (    match goal with
    | H :  valid_syntax (_ _ _) |- _
      => inversion H; subst; auto
    | H :  valid_syntax (_ _ _ _) |- _
      => inversion H; subst; auto 
    end;
    intros; 
    intro contra; inversion contra);
    apply stack_frame_wfe; auto;
    intros x v0; intro Hy. 
    match goal with
    | H : wfe_stack_frame  _ _ _ |- _
      => inversion H; subst; auto
    end;

    unfold sf_update in Hy; auto;
    case_eq (beq_id id x); intro;
      rewrite H2 in Hy;
    inversion Hy; subst; auto;
      split; auto.
    try (apply typed_value_is_wfe_stack_val with T0 gamma; auto).
    destruct H1 with x v0; auto.

    destruct H1 with x v0; auto.
    unfold sf_update in Hy;
    case_eq (beq_id id x); intro;
      rewrite H12 in Hy.
    inversion Hy; subst; auto. 
    split; auto.
    apply typed_value_is_wfe_stack_val with T0 gamma; auto.
    inversion H11; subst; auto.
    destruct H15 with x v0; auto. 

   - match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
     end.
     apply valid_conf; auto.
     apply valid_container; auto.
     apply valid_fs_list; auto.
     try (
         match goal with
    | H :  valid_syntax (_ _ _) |- _
      => inversion H; subst; auto
    | H :  valid_syntax (_ _ _ _) |- _
      => inversion H; subst; auto
        end; auto).

    intro contra. inversion contra. 
    intro contra. inversion contra.
    try (
         match goal with
    | H :  valid_syntax (_ _ _) |- _
      => inversion H; subst; auto
    | H :  valid_syntax (_ _ _ _) |- _
      => inversion H; subst; auto
         end; auto).
      intros;
    intro contra; inversion contra.
    intros;
      intro contra; inversion contra.
    match goal with
    | H :  hole_free  _ = true |- _
      => inversion H; subst; auto;
           match goal with
           | H : (if hole_free _ then hole_free _ else false) = true |- _
             => apply hole_free_if in H; destruct H
           end
    end.
    rewrite H0; auto. 

   -  match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
      end.
      inversion H4; subst; auto.
     apply valid_conf; auto.
     apply valid_container; auto.     
    try (
         match goal with
    | H :  valid_syntax (_ _ _) |- _
      => inversion H; subst; auto
    | H :  valid_syntax (_ _ _ _) |- _
      => inversion H; subst; auto
         end; auto).
      intros;
        intro contra; inversion contra;
          rewrite contra in H3; inversion H3; intuition.
            intros;
        intro contra; inversion contra;
          rewrite contra in H3; inversion H3; intuition.
            inversion H2; subst; auto; try (inversion H12).
            apply surface_syntax_is_hole_free in H1; auto.
            unfold hole_free. fold hole_free.
            rewrite H1; rewrite H17. auto. 

   -  match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
     end.
     apply valid_conf; auto.
     apply valid_container; auto.
     apply valid_fs_list; auto.
     intro contra; inversion contra.
     intro contra; inversion contra.
     try (
         match goal with
    | H :  valid_syntax (_ _ _) |- _
      => inversion H; subst; auto
    | H :  valid_syntax (_ _ _ _) |- _
      => inversion H; subst; auto
        end; auto).
    intro. intro contra. inversion contra. 
    intro. intro contra. inversion contra.
    match goal with
    | H :  hole_free  _ = true |- _
      => inversion H; subst; auto;
           match goal with
           | H : (if hole_free _ then hole_free _ else false) = true |- _
             => apply hole_free_if in H; destruct H
           end
    end.
    rewrite H3; auto.  rewrite H2; auto.

   -  match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
      end.
      inversion H5; subst; auto.
     apply valid_conf; auto.
     apply valid_container; auto.
     intro. intro contra.
     rewrite contra in H4;
       inversion H4; subst; auto.
     intro. intro contra.
     rewrite contra in H4;
       inversion H4; subst; auto.
     unfold hole_free. fold hole_free.
     apply value_is_hole_free in H. 
     apply value_is_hole_free in H0.
     rewrite H. rewrite H0. auto. 

   - inversion H20; subst; auto.
     apply config_typing_lead_to_tm_typing in H_typing.
     destruct H_typing as [T'].
     destruct H0 as [gamma].
     inversion H0; subst; auto.
     inversion H7; subst; auto.
     destruct H25 as [F'].
     destruct H2 as [lo'].
     rewrite H2 in H; inversion H; subst; auto.
     rewrite <- H19 in H5; inversion H5; subst; auto. 
     
     apply valid_conf; auto.
     destruct H18 as [field_defs].
     destruct H4 as [method_defs].
     apply field_write_preserve_wfe_heap with o h0 f F' (fields_update F' f v)
                                              cls_def cls' lo' lo' clsT
                                              field_defs method_defs; auto. 
     destruct H18 as [field_defs].
     destruct H4 as [method_defs].
     inversion H16; subst; auto.
     inversion H14; subst; auto.
     apply field_write_preserve_field_wfe with gamma h0 o field_defs
                                               method_defs lo'
                                               lo' v f F' (class_def clsT field_defs method_defs) clsT cls'; auto. 
     
   -  match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
      end.
     apply valid_conf; auto.
     apply valid_container; auto.
     inversion H17; subst; auto.
     apply valid_fs_list; auto.
     inversion H7; subst; auto.
     intro contra; inversion contra. 
     intro contra; inversion contra.
     inversion H7; subst; auto.
     intro. intro contra; inversion contra. 
     intro. intro contra; inversion contra.
     inversion H17; subst; auto.
     apply hole_free_if_triple in H1.
     destruct H1. destruct H1.
     rewrite H0. rewrite H1. rewrite H2. auto. 
     
   -  match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
      end.
      inversion H4; subst; auto.
      
      inversion H_typing; subst; auto.
      inversion H21; subst; auto.
      inversion H27; subst; auto. 
      inversion H22; subst; auto.
      inversion H24; subst; auto. 
      inversion H28; subst; auto.

      induction H; subst; auto; inversion H23.
      subst; auto.
      apply valid_conf; auto.
      apply valid_container; auto.
      inversion H2; subst; auto.
      intro. intro contra.
      rewrite contra in H3; inversion H3; subst; auto.
      intro. intro contra.
      rewrite contra in H3; inversion H3; subst; auto.
      inversion H2; subst; auto. inversion H12. 
      unfold hole_free. fold hole_free.
      apply surface_syntax_is_hole_free in H1.
      apply surface_syntax_is_hole_free in H12.
      rewrite H1. rewrite H12. auto.

      subst; auto.
      apply valid_conf; auto.
      apply valid_container; auto.
      inversion H2; subst; auto.
      intro. intro contra.
      rewrite contra in H3; inversion H3; subst; auto.
      inversion H2; subst; auto. inversion H12.
      intro. intro contra.
      rewrite contra in H3; inversion H3; subst; auto.
      unfold hole_free. fold hole_free.
      inversion H2; subst; auto.
      inversion H12. 
      apply surface_syntax_is_hole_free in H1.
      apply surface_syntax_is_hole_free in H12.
      rewrite H1. rewrite H12. auto.

      subst; auto. 
      apply valid_conf; auto.
      apply valid_container; auto.
      inversion H2; subst; auto.
      intro. intro contra.
      rewrite contra in H3; inversion H3; subst; auto.
      inversion H2; subst; auto. inversion H12.
      intro. intro contra.
      rewrite contra in H3; inversion H3; subst; auto.
      unfold hole_free. fold hole_free.
      inversion H2; subst; auto.
      inversion H12. 
      apply surface_syntax_is_hole_free in H1.
      apply surface_syntax_is_hole_free in H12.
      rewrite H1. rewrite H12. auto.      

      destruct H23.
      pose proof (H1 (If hole s1 s2) fs ); intuition. 
      
      inversion H20. 
      subst; auto.
      inversion H29; subst; auto.
      inversion H24.   inversion H26.
      inversion H30. 

      apply valid_conf; auto.
      apply valid_container; auto.
      inversion H2; subst; auto.
      inversion H14. 

      induction H; subst; auto; inversion H25.
      intro. intro contra.
      rewrite contra in H3; inversion H3; subst; auto.
      intro. intro contra.
      rewrite contra in H3; inversion H3; subst; auto.
      inversion H2; subst; auto. inversion H14. 
      unfold hole_free. fold hole_free.
      apply surface_syntax_is_hole_free in H12.
      apply surface_syntax_is_hole_free in H14.
      rewrite H14. rewrite H12. auto. rewrite H17. auto. 

      subst; auto.
      apply valid_conf; auto.
      apply valid_container; auto.

      destruct H25.
      pose proof (H1 (If hole s1 s2) fs); intuition.       

      intros. intro contra. rewrite contra in H3. inversion H3; intuition.  
      intros. intro contra. rewrite contra in H3. inversion H3; intuition.  

      unfold hole_free. fold hole_free.
      inversion H2; subst; auto.  inversion H14.
      apply surface_syntax_is_hole_free in H12.
      apply surface_syntax_is_hole_free in H14.
      rewrite H14. rewrite H12. auto. rewrite H17. auto. 

   -   match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
      end.
     apply valid_conf; auto.
     apply valid_container; auto.
     try (
         match goal with
    | H :  valid_syntax (_ _ _) |- _
      => inversion H; subst; auto
    | H :  valid_syntax (_ _ _ _) |- _
      => inversion H; subst; auto
         end; auto).
     inversion H16; subst; auto.
     apply hole_free_if in H0.
     destruct H0. rewrite H. rewrite H0. auto. 

   -   match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
      end.
     apply valid_conf; auto.
     apply valid_container; auto.
     try (
         match goal with
    | H :  valid_syntax (_ _ _) |- _
      => inversion H; subst; auto
    | H :  valid_syntax (_ _ _ _) |- _
      => inversion H; subst; auto
         end; auto).
     inversion H16; subst; auto.
     apply hole_free_if in H0.
     destruct H0. rewrite H. rewrite H0. auto. 


   -   match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
       end.
       apply valid_conf; auto.
       inversion H6; subst; auto.
     apply valid_container; auto.
     apply valid_fs_list; auto.  
     try (
         match goal with
    | H :  valid_syntax (_ _ _) |- _
      => inversion H; subst; auto
    | H :  valid_syntax (_ _ _ _) |- _
      => inversion H; subst; auto
         end; auto).     
     apply surface_syntax_is_hole_free in H2.
     intro contra. subst; auto. inversion H2.
     inversion H6; subst; auto.
     intro contra. subst; auto.
     unfold surface_syntax in H2. discriminate. 
     try (
         match goal with
    | H :  valid_syntax (_ _ _) |- _
      => inversion H; subst; auto
    | H :  valid_syntax (_ _ _ _) |- _
      => inversion H; subst; auto
         end; auto).
     intro. intro contra. inversion contra.
     subst; auto. inversion H2. 
     intro. intro contra. inversion contra.
     subst; auto. inversion H2. 
     inversion H6; subst; auto.     


   -   match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
       end.
       apply valid_conf; auto.
       inversion H3; subst; auto. 
       apply valid_container; auto.
       intro. intro contra.
       rewrite contra in H2; inversion H2;
         subst; auto.
       intro. intro contra.
       rewrite contra in H2; inversion H2;
         subst; auto.
       inversion H_typing;subst; auto.
       inversion H11; subst; auto.
       inversion H14; subst; auto. 

       destruct H21; intuition.
       destruct H14. 
       pose proof (H0 e fs). intuition.

       inversion H7; subst; auto.
       inversion H20; subst; auto.
       destruct H23; intuition. 

       destruct H20.
       pose proof (H0 e fs). intuition.

   -   match goal with
    | H : valid_ctn _ _ _ |- _
      => inversion H; subst; auto 
       end.
       inversion H13; subst; auto.
       inversion H3; subst; auto.
Admitted. Hint Resolve valid_config_preservation. 



(*
Inductive well_typed_ctn : Class_table -> typing_context ->
                           stack_frame -> heap -> Prop :=           
| well_typed_sf_obj :  forall ct sf gamma x h cls_def F lb o clsT field_defs method_defs,
    gamma x = Some (classTy clsT) ->
    sf x = Some (ObjId o) ->
    cls_def = class_def clsT field_defs method_defs -> 
    lookup_heap_obj h o = Some (Heap_OBJ cls_def F lb) ->
    well_typed_ctn ct gamma sf h
| well_typed_sf_lb : forall ct sf gamma x h lb,
    gamma x = Some LabelTy ->
    sf x = Some lb ->
    well_typed_ctn ct gamma sf h
| well_typed_sf_labeled_v : forall sf ct gamma x h lb v T,
    tm_has_type ct gamma h v T ->
    gamma x = Some LabelTy ->
    sf x = Some lb ->
    well_typed_ctn ct gamma sf h.         
                   
    *)

Ltac inconsist_hole_free :=
  match goal with
  | H : hole_free  (_ hole)  = true |- _
    =>  solve [inversion H]
  | H : hole_free  (_ hole _)  = true |- _
    =>  solve [inversion H]
  | H : hole_free  (_ hole _ _)  = true |- _
    =>  solve [inversion H]
  | H : hole_free  (_ _ _ hole)  = true |- _
    =>  solve [inversion H]
  | H : surface_syntax hole = true |- _
    => solve [inversion H]
  | H : value hole  |- _
    => solve [inversion H]
  end. 
  

Ltac destruct_hole_free :=
  match goal with
  |  H : forall (top : tm) (fs' : list tm),
      ?X :: ?Y = top :: fs'
      -> hole_free top = true |- _
     => pose proof (H ?X ?Y) as Hy;
        simpl in Hy; intuition 
  end.

Ltac destructs :=
  match goal with
  | H : _ /\ _ |- _
    => destruct H; destructs
  end.


Lemma typing_preservation : forall T ct
                                   ctn ctns h
                                   ctn' ctns' h',
    config_has_type ct empty_context (Config ct ctn ctns h) T ->
    valid_config (Config ct  ctn ctns h) ->
    Config ct ctn ctns h
           ==> Config ct ctn' ctns' h' ->
    config_has_type ct empty_context (Config ct ctn' ctns' h') T.
Proof with eauto.
  intros T ct ctn ctns h ctn' ctns' h'. 
  intro H_typing.
  intro H_valid_config. 
  remember (empty_context) as Gamma.
  intro H_reduction.
  remember (Config ct ctn ctns h) as config. 
  remember (Config ct ctn' ctns' h') as config'.
  generalize dependent T.   generalize dependent h.
  generalize dependent ctn. 
  generalize dependent ctns. 
  generalize dependent h'.
  generalize dependent ctn'. 
  generalize dependent ctns'.
  induction H_reduction; intros; inversion Heqconfig; inversion Heqconfig'; subst; auto.

  - (*Tvar*)
    inversion H_typing; subst;auto.
    + inversion H7; subst; auto.
      inversion H11. subst; auto. 
      
      inversion H9; subst; auto.
      inversion H6.
      
      inversion H11; subst; auto.
      inversion H4.

    + inversion H6; subst; auto.
      inversion H13; subst; auto.
      inversion H11; subst; auto.
      assert (tm_has_type ct Gamma' h' v (classTy T0) ).
      apply H0 with id; auto.
      ++ eauto using config_has_type.
      ++ inversion H13; subst; auto.
         destruct H14. 
         inversion H0; subst; auto.         
         assert (tm_has_type ct Gamma' h' v (classTy T0) ).
         apply H2 with id; auto.
         eauto using config_has_type.
(*
    + inversion H17; subst; auto.
      inversion H13; subst; auto.
      inversion H14; subst; auto.
     
      apply H0 with id v (classTy T2) in H4; auto.
      apply T_config_ctns with (OpaqueLabeledTy (classTy returnT))
      (update_typing empty_context arg_id (classTy arguT)); auto. 
      eauto using T_ctn_fs.
      intro contra. inversion contra.

      inversion H14; subst; auto.
      apply T_config_ctns with (OpaqueLabeledTy (classTy returnT))
                               (update_typing empty_context arg_id (classTy arguT)); auto.
      apply T_ctn_sequential_exec with (classTy T3) T2; auto.
      inversion H18; subst; auto.
      apply H0 with id v (classTy T3) in H4; auto.
      intro contra. inversion contra.
*)

  (*field access*)
  -  inversion H_typing; subst; auto.
     + apply T_config_nil; auto.
       inversion H7; subst; auto.
       ++ inversion H9; subst; auto.
          apply T_ctn_fs with (classTy clsT) ; auto.
          intro contra. inversion contra.
          apply T_fs_FieldAccess with cls' (find_fields cls_def) cls_def (classTy cls'); auto. 
          apply T_FieldAccess with cls_def clsT (find_fields cls_def); auto.
          
       ++ inversion H11; subst; auto.
          apply T_ctn_fs with (classTy clsT) ; auto.
          intro contra. inversion contra.
          apply T_fs_FieldAccess with cls' (find_fields cls_def) cls_def T1; auto. 
          apply T_FieldAccess with cls_def clsT (find_fields cls_def); auto.
          intros.
          inversion H0; subst; auto.
          destruct H9. 
          assert (hole_free top = true).
          apply H6 with fs';auto.
          try (inconsist).
          intro. apply H9 in H0; auto. 

     + apply T_config_ctns with T0 Gamma'; auto.
       inversion H6; subst; auto.
       ++ inversion H11; subst; auto.
          apply T_ctn_fs with (classTy clsT) ; auto.
          intro contra. inversion contra.
          eauto using fs_has_type.
       ++ inversion H13; subst; auto.
          apply T_ctn_fs with (classTy clsT) ; auto.
          intro contra. inversion contra.
          apply T_fs_FieldAccess with cls' (find_fields cls_def) cls_def T2; auto. 
          apply T_FieldAccess with cls_def clsT (find_fields cls_def); auto.
          intros.
          inversion H0; subst; auto.
          destruct H11.
          
          assert (hole_free top = true).
          apply H7 with fs';auto.
          try (inconsist).
          intro. destruct H11.
          apply H1 in H0. auto.

          
  (*field access return v to hole *)
  - inversion H_typing; subst; auto. 
    + apply T_config_nil. inversion H7; subst; auto.  
     inversion H13; subst; auto; try (inconsist_hole_free).
      ++ destruct fs.
         +++ apply T_ctn_sequential_exec with (classTy cls') T1; auto.
             split; auto.
             intros.  inversion H0.
             eauto using tm_has_type.
         +++ case_eq (hole_free t); intro.
             ++++
               apply T_ctn_sequential_exec with (classTy cls') T1; auto.
               split; auto.
               intros. 
             inversion H1; subst; auto.              
             eauto using tm_has_type.
             ++++
               apply H18 with t fs in H0; subst; auto.
               apply T_ctn_fs with (classTy cls'); auto.
               eauto using tm_has_type.
               intro contra. inversion contra.

      ++ destruct H9.
         pose proof (H1 (FieldAccess hole f) fs) as Hy;
           simpl in Hy; intuition.

    +  apply T_config_ctns with T0 Gamma'; auto.
       inversion H6; subst; auto.  
     inversion H15; subst; auto; try (inconsist_hole_free).
      ++ destruct fs.
         +++ apply T_ctn_sequential_exec with (classTy cls') T0; auto.
             split; auto.
             intros. inversion H0.
             eauto using tm_has_type.
         +++ case_eq (hole_free t); intro.
             ++++
               apply T_ctn_sequential_exec with (classTy cls') T0; auto.
               split; auto; intros.
               inversion H1; subst; auto.
               eauto using tm_has_type.
             ++++
               apply H20 with t fs in H0; subst; auto.
               apply T_ctn_fs with (classTy cls'); auto.
               eauto using tm_has_type.
               intro contra. inversion contra.

      ++ destruct H11.
         pose proof (H1 (FieldAccess hole f) fs) as Hy;
           simpl in Hy; intuition.

  - inversion H_typing; subst; auto.
    + apply T_config_nil.
      inversion H8; subst;auto. 

      ++ inversion H10; subst; auto.
         apply T_ctn_fs with (classTy cls'); auto.
         inversion H3; subst; auto.   
         destruct H15 as [field_defs].
         destruct H1 as [method_defs].
         assert (v = null \/
             (exists
                (o' : oid) (field_defs0 : list field) (method_defs0 : 
                                                       list method_def) 
              (field_cls_def : CLASS) (F' : FieldMap) (lo : Label),
                v = ObjId o' /\
                field_cls_def =
                class_def cls' field_defs0 method_defs0 /\
                lookup_heap_obj h' o'  = Some (Heap_OBJ field_cls_def F' lo) /\
                ct cls' = Some field_cls_def)
      ).
      inversion H_valid_config; subst; auto. 
      destruct H17 as [F0].
      destruct H1 as [lo0].
      rewrite H1 in H. inversion H; subst; auto.
      apply field_consist_typing with o cls_def F0 fname lo0 clsT field_defs method_defs; auto.
      rewrite <- H4 in H5. inversion H5; subst;  auto.
      rewrite <- H4 in H5. inversion H5.  auto. 
      rewrite <- H4 in H5. inversion H5.  auto.
      rewrite <- H6 in H16.    
      unfold find_fields in H16. auto.
      
      destruct H2. subst; auto.
      destruct H2 as [o'].
      destruct H2 as [field_defs0]. 
      destruct H2 as [method_defs0].
      destruct H2 as [field_cls_def].
      destruct H2 as [FF].
      destruct H2 as [loF].
      destruct H2.
      destruct H6. destruct H9. subst;auto.
      apply T_ObjId with  (class_def cls' field_defs0 method_defs0); auto.
      exists field_defs0. exists method_defs0. auto. 
      exists FF. exists loF. auto.
      
      ++ inversion H12; subst; auto.
         
         apply T_ctn_sequential_exec  with  (classTy cls') T1; auto.
         inversion H3; subst; auto.   
         destruct H15 as [field_defs].
         destruct H1 as [method_defs].
         assert (v = null \/
             (exists
                (o' : oid) (field_defs0 : list field) (method_defs0 : 
                                                       list method_def) 
              (field_cls_def : CLASS) (F' : FieldMap) (lo : Label),
                v = ObjId o' /\
                field_cls_def =
                class_def cls' field_defs0 method_defs0 /\
                lookup_heap_obj h' o'  = Some (Heap_OBJ field_cls_def F' lo) /\
                ct cls' = Some field_cls_def)
      ).
      inversion H_valid_config; subst; auto. 
      destruct H17 as [F0].
      destruct H1 as [lo0].
      rewrite H1 in H. inversion H; subst; auto.
      apply field_consist_typing with o cls_def F0 fname lo0 clsT field_defs method_defs; auto.
      rewrite <- H4 in H5. inversion H5; subst;  auto.
      rewrite <- H4 in H5. inversion H5.  auto. 
      rewrite <- H4 in H5. inversion H5.  auto.
      rewrite <- H6 in H16.    
      unfold find_fields in H16. auto.
      
      destruct H2. subst; auto.
      destruct H2 as [o'].
      destruct H2 as [field_defs0]. 
      destruct H2 as [method_defs0].
      destruct H2 as [field_cls_def].
      destruct H2 as [FF].
      destruct H2 as [loF].
      destruct H2.
      destruct H6. destruct H9. subst;auto.
      apply T_ObjId with  (class_def cls' field_defs0 method_defs0); auto.
      exists field_defs0. exists method_defs0. auto. 
      exists FF. exists loF. auto.

    + apply T_config_ctns with T0 Gamma'; auto.
      inversion H6; subst;auto. 
      ++ inversion H12; subst; auto.
         apply T_ctn_fs with (classTy cls'); auto.
         inversion H3; subst; auto.   
         destruct H17 as [field_defs].
         destruct H1 as [method_defs].
         assert (v = null \/
             (exists
                (o' : oid) (field_defs0 : list field) (method_defs0 : 
                                                       list method_def) 
              (field_cls_def : CLASS) (F' : FieldMap) (lo : Label),
                v = ObjId o' /\
                field_cls_def =
                class_def cls' field_defs0 method_defs0 /\
                lookup_heap_obj h' o'  = Some (Heap_OBJ field_cls_def F' lo) /\
                ct cls' = Some field_cls_def)
      ).
      inversion H_valid_config; subst; auto. 
      destruct H19 as [F0].
      destruct H1 as [lo0].
      rewrite H1 in H; inversion H; subst; auto.
      apply field_consist_typing with o cls_def F0 fname lo0 clsT field_defs method_defs; auto.
      rewrite <- H4 in H5. inversion H5; subst;  auto.
      rewrite <- H4 in H5. inversion H5.  auto. 
      rewrite <- H4 in H5. inversion H5.  auto.
      rewrite <- H8 in H18.    
      unfold find_fields in H18; auto.
      
      destruct H2. subst; auto.
      destruct H2 as [o'].
      destruct H2 as [field_defs0]. 
      destruct H2 as [method_defs0].
      destruct H2 as [field_cls_def].
      destruct H2 as [FF].
      destruct H2 as [loF].
      destruct H2.
      destruct H8. destruct H11. subst;auto.
      apply T_ObjId with  (class_def cls' field_defs0 method_defs0); auto.
      exists field_defs0. exists method_defs0. auto. 
      exists FF. exists loF. auto.
      
      ++  inversion H14; subst; auto.
         apply T_ctn_sequential_exec  with  (classTy cls') T2; auto.
         inversion H3; subst; auto.   
         destruct H17 as [field_defs].
         destruct H1 as [method_defs].
         assert (v = null \/
             (exists
                (o' : oid) (field_defs0 : list field) (method_defs0 : 
                                                       list method_def) 
              (field_cls_def : CLASS) (F' : FieldMap) (lo : Label),
                v = ObjId o' /\
                field_cls_def =
                class_def cls' field_defs0 method_defs0 /\
                lookup_heap_obj h' o'  = Some (Heap_OBJ field_cls_def F' lo) /\
                ct cls' = Some field_cls_def)
      ).
      inversion H_valid_config; subst; auto. 
      destruct H19 as [F0].
      destruct H1 as [lo0].
      rewrite H1 in H; inversion H; subst; auto.
      apply field_consist_typing with o cls_def F0 fname lo0 clsT field_defs method_defs; auto.
      rewrite <- H4 in H5. inversion H5; subst;  auto.
      rewrite <- H4 in H5. inversion H5.  auto. 
      rewrite <- H4 in H5. inversion H5.  auto.
      rewrite <- H8 in H18.    
      unfold find_fields in H18; auto.
      
      destruct H2. subst; auto.
      destruct H2 as [o'].
      destruct H2 as [field_defs0]. 
      destruct H2 as [method_defs0].
      destruct H2 as [field_cls_def].
      destruct H2 as [FF].
      destruct H2 as [loF].
      destruct H2.
      destruct H8. destruct H11. subst;auto.
      apply T_ObjId with  (class_def cls' field_defs0 method_defs0); auto.
      exists field_defs0. exists method_defs0. auto. 
      exists FF. exists loF. auto.
(*
  + inversion H17.
*)
  (* method call context *)
  - inversion H_typing; subst; auto. 
    + apply T_config_nil; subst; auto.
      inversion H7; subst; auto. 
      ++ inversion H9; subst;auto.
         rename id into meth. 
         apply T_ctn_fs with  (classTy T); auto. 
         intro contra; inversion contra.
         remember (update_typing empty_context arg_id (classTy arguT)) as gamma0.
         apply T_fs_MethodCall1 with gamma0 e returnT cls_def
                                     body arg_id arguT
                                     (OpaqueLabeledTy (classTy returnT)); auto.
      ++ inversion H11; subst;auto.
         rename id into meth.
         apply T_ctn_fs  with  (classTy T); auto.
         intro contra; inversion contra.
         remember (update_typing empty_context arg_id (classTy arguT)) as gamma0.
         apply T_fs_MethodCall1 with gamma0 e returnT cls_def body arg_id arguT T1; auto.

         destruct H9; subst; auto; intros.
         pose proof (H1 top fs') as Hy; intuition.
         try (inconsist).
         intros. apply H9; auto.

    + apply T_config_ctns with T0 Gamma'; subst; auto.
      inversion H6; subst; auto. 
      ++ inversion H11; subst;auto.
         rename id into meth. 
         apply T_ctn_fs with  (classTy T0); auto. 
         intro contra; inversion contra.
         remember (update_typing empty_context arg_id (classTy arguT)) as gamma0.
         apply T_fs_MethodCall1 with gamma0 e returnT cls_def
                                     body arg_id arguT
                                     (OpaqueLabeledTy (classTy returnT)); auto.
      ++ inversion H13; subst;auto.
         rename id into meth.
         apply T_ctn_fs  with  (classTy T0); auto.
         intro contra; inversion contra.
         remember (update_typing empty_context arg_id (classTy arguT)) as gamma0.
         apply T_fs_MethodCall1 with gamma0 e returnT cls_def body arg_id arguT T2; auto.

         destruct H11; subst; auto; intros.
         pose proof (H1 top fs') as Hy; intuition.
         try (inconsist).

         intros. apply H11; auto. 

(*(MethodCall t id0 e2) *)
  -   inversion H_typing; subst; auto.
      + apply T_config_nil.
        inversion H7; subst;auto.
        ++ inversion H13; subst; auto; (try inconsist_hole_free).
           destruct fs.
           +++ apply T_ctn_sequential_exec with (OpaqueLabeledTy (classTy returnT))
                                                T1; auto.
               split; auto.
               intros. inversion H0. 
               eauto using tm_has_type.               
           +++ case_eq (hole_free t); intro.
             ++++
               apply T_ctn_sequential_exec with (OpaqueLabeledTy (classTy returnT))
                                                T1; auto.
               split; auto.
               intros. inversion H1; subst; auto.              
               eauto using tm_has_type.
             ++++
               apply H22 with t fs in H0; subst; auto.
               apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT)); auto.
               eauto using tm_has_type.
               intro contra. inversion contra.
           +++ inversion H_valid_config; subst; auto.
               inversion H18; subst; auto.
               inversion H4; subst; auto.
               inversion H2; subst; auto; try (inconsist_hole_free).
        ++ destruct H9.
           pose proof (H1 (MethodCall hole id e2) fs) as Hy;
           simpl in Hy; intuition.

      + apply T_config_ctns with T0 Gamma'; subst; auto. 
        inversion H6; subst;auto.
        ++ inversion H15; subst; auto; (try inconsist_hole_free).
           destruct fs.
           +++ apply T_ctn_sequential_exec with (OpaqueLabeledTy (classTy returnT))
                                                T2; auto.
               split; auto.
               intros. inversion H0.
               eauto using tm_has_type.               
           +++ case_eq (hole_free t); intro.
             ++++
               apply T_ctn_sequential_exec with (OpaqueLabeledTy (classTy returnT))
                                                T2; auto.
               split; auto.
               intros. inversion H1; subst; auto.      
               eauto using tm_has_type.
             ++++
               apply H24 with t fs in H0; subst; auto.
               apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT)); auto.
               eauto using tm_has_type.
               intro contra. inversion contra.
           +++ inversion H_valid_config; subst; auto.
               inversion H20; subst; auto.
               inversion H4; subst; auto.
               inversion H2; subst; auto; try (inconsist_hole_free).
        ++ destruct H11.          
         pose proof (H1 (MethodCall hole id e2) fs) as Hy;
           simpl in Hy; intuition.

 (*(MethodCall v1 id v2) *)        
 -   inversion H_typing; subst; auto.
      + apply T_config_nil.
        inversion H8; subst;auto.
        ++ inversion H14; subst; auto; (try inconsist_hole_free).
           inversion H9;
             pose proof (value_is_hole_free v1 H); rewrite H1 in H2; intuition.
           inversion H11; 
             pose proof (value_is_hole_free v1 H); rewrite H1 in H2; intuition.
           inversion H15; 
             pose proof (value_is_hole_free v1 H); rewrite H1 in H2; intuition.
           destruct fs.
           +++ apply T_ctn_sequential_exec with (OpaqueLabeledTy (classTy returnT))
                                                T1; auto.
               split; auto.
               intros. inversion H1 .
               eauto using tm_has_type.               
           +++ case_eq (hole_free t); intro.
             ++++
               apply T_ctn_sequential_exec with (OpaqueLabeledTy (classTy returnT))
                                                T1; auto.
               split; auto.
               intros. inversion H2; subst; auto.      
               eauto using tm_has_type.
             ++++
               apply H23 with t fs in H1; subst; auto.
               apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT)); auto.
               eauto using tm_has_type.
               intro contra. inversion contra.
        ++ destruct H10.
         pose proof (H2 (MethodCall v1 id hole) fs) as Hy;
           simpl in Hy; intuition.
         inversion H3;
           pose proof (value_is_hole_free v1 H); rewrite H4 in H3; intuition.
        
      + apply T_config_ctns with T0 Gamma'; subst; auto. 
        inversion H7; subst;auto.
        ++ inversion H16; subst; auto; (try inconsist_hole_free).
           inversion H11;
             pose proof (value_is_hole_free v1 H); rewrite H1 in H2; intuition.
           inversion H13; 
             pose proof (value_is_hole_free v1 H); rewrite H1 in H2; intuition.
           inversion H17; 
             pose proof (value_is_hole_free v1 H); rewrite H1 in H2; intuition.
           destruct fs.
           +++ apply T_ctn_sequential_exec with (OpaqueLabeledTy (classTy returnT))
                                                T2; auto.
               split; auto.
               intros. inversion H1. 
               eauto using tm_has_type.               
           +++ case_eq (hole_free t); intro.
             ++++
               apply T_ctn_sequential_exec with (OpaqueLabeledTy (classTy returnT))
                                                T2; auto.
               split; auto.
               intros. inversion H2; subst; auto.               
               eauto using tm_has_type.
             ++++
               apply H25 with t fs in H1; subst; auto.
               apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT)); auto.
               eauto using tm_has_type.
               intro contra. inversion contra.
           
        ++ destruct H12.
           pose proof (H2 (MethodCall v1 id hole) fs) as Hy;
           simpl in Hy; intuition.
         inversion H3;
             pose proof (value_is_hole_free v1 H); rewrite H4 in H3; intuition.

 (*(Container t' (MethodCall v id0 hole :: fs0) lb' sf')  *)
  - inversion H_typing; subst; auto. 
    + apply T_config_nil; subst; auto.
      inversion H9; subst; auto. 
      ++ inversion H11; subst;auto.
         rename id into meth. 
         apply T_ctn_fs with  (classTy arguT); auto. 
         intro contra; inversion contra.
         remember (update_typing empty_context arg_id (classTy arguT)) as gamma0.
         eauto using  T_fs_MethodCall2.
      ++ inversion H13; subst;auto.
         rename id into meth.
         apply T_ctn_fs  with  (classTy arguT); auto.
         intro contra; inversion contra.
         remember (update_typing empty_context arg_id (classTy arguT)) as gamma0.
         apply T_fs_MethodCall2 with gamma0 e2 T returnT cls_def body arg_id T1; auto.

         destruct H11; subst; auto; intros.
         pose proof (H3 top fs') as Hy; intuition.
         try (inconsist).
         apply H11; auto.

    + apply T_config_ctns with T0 Gamma'; subst; auto.
      inversion H8; subst; auto. 
      ++ inversion H13; subst;auto.
         rename id into meth. 
         apply T_ctn_fs with  (classTy arguT); auto. 
         intro contra; inversion contra.
         remember (update_typing empty_context arg_id (classTy arguT)) as gamma0.
         eauto using  T_fs_MethodCall2.
      ++ inversion H15; subst;auto.
         rename id into meth.
         apply T_ctn_fs  with  (classTy arguT); auto.
         intro contra; inversion contra.
         remember (update_typing empty_context arg_id (classTy arguT)) as gamma0.
         apply T_fs_MethodCall2 with gamma0 e2 T0 returnT cls_def body arg_id T2; auto.
         destruct H13; subst; auto; intros.
         pose proof (H3 top fs') as Hy; intuition.
         try (inconsist).
         apply H13; auto.
(*
    + remember ((update_typing empty_context arg_id (classTy arguT))) as Gamma'.
      apply T_config_ctns with ((OpaqueLabeledTy (classTy returnT))) Gamma'; subst; auto.
      inversion H19; subst; auto. 
      ++ inversion H15; subst;auto.
         rename id into meth'. 
         apply T_ctn_fs with  (classTy arguT0); auto. 
         intro contra; inversion contra.
         remember (update_typing empty_context arg_id0 (classTy arguT0)) as gamma0.
         eauto using  T_fs_MethodCall2.
      ++ inversion H16; subst;auto.
         rename id into meth'.
         apply T_ctn_fs  with  (classTy  arguT0); auto.
         intro contra; inversion contra.
         remember (update_typing empty_context arg_id0 (classTy arguT0)) as gamma0.
         apply T_fs_MethodCall2 with gamma0 e2 T3 returnT0 cls_def0 body arg_id0 T2; auto.
         
         destruct H15; subst; auto; intros. 
         inversion H3; subst; auto.
         inversion H3; subst; auto. 
      ++ intro contra. inversion contra. 
 *)
         
(* (Container body nil lb (sf_update empty_stack_frame arg_id v))  *)
  - inversion H_typing; subst; auto.  
    ++ inversion H10; subst; auto. 
       +++  inversion H12; subst; auto. 
            inversion H6; subst; auto.
            destruct H20 as [F0]. 
            destruct H3 as [lo0].
            rewrite H3 in H; inversion H; subst; auto.
            rewrite <- H5 in H8. inversion H8; subst; auto.
            rewrite H11 in H0; inversion H0; subst; auto.
            remember ( (update_typing empty_context arg_id0 (classTy arguT))) as gamma0.
            apply T_config_ctns with (OpaqueLabeledTy (classTy returnT0)) gamma0; auto.
            apply T_ctn_fs with (classTy returnT0); auto.
            admit.
            intro contra. inversion contra.
            apply T_ctn_list with fs lb sf empty_context T'
                                  (OpaqueLabeledTy (classTy returnT0)); auto.
            apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT0)); auto.
       +++  inversion H14; subst; auto. 
            inversion H6; subst; auto.
            destruct H20 as [F0]. 
            destruct H3 as [lo0].
            rewrite H3 in H; inversion H; subst; auto.
            rewrite <- H5 in H8. inversion H8; subst; auto.
            rewrite H11 in H0; inversion H0; subst; auto.
            remember ( (update_typing empty_context arg_id0 (classTy arguT))) as gamma0.
            apply T_config_ctns with (OpaqueLabeledTy (classTy returnT0)) gamma0; auto.

            apply T_ctn_fs with (classTy returnT0); auto.
            admit.
            intro contra. inversion contra.
            intro contra. inversion contra.
            apply T_ctn_list with fs lb sf empty_context T'
                                  T1; auto.
            apply T_ctn_sequential_exec with T1 T1; auto.
            intros.
            split; auto.
            intros.
            destruct H12. 
            pose proof (H13 top fs') as Hy; intuition.
            intros. destruct H12.
            pose proof (H17 top fs') as Hy; intuition.
            try (inconsist).
    ++ inversion H8; subst; auto. 
       +++  inversion H14; subst; auto. 
            inversion H6; subst; auto.
            destruct H22 as [F0]. 
            destruct H3 as [lo0].
            rewrite H3 in H; inversion H; subst; auto.
            rewrite <- H5 in H10. inversion H10; subst; auto.
            rewrite H13 in H0; inversion H0; subst; auto.
            remember ( (update_typing empty_context arg_id0 (classTy arguT))) as gamma0.
            apply T_config_ctns with (OpaqueLabeledTy (classTy returnT0)) gamma0; auto.

            apply T_ctn_fs with (classTy returnT0); auto.
            admit.
            intro contra. inversion contra.
            apply T_ctn_list with fs lb sf Gamma' T'
                                  (OpaqueLabeledTy (classTy returnT0)); auto.
            apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT0)); auto.
       +++  inversion H16; subst; auto. 
            inversion H6; subst; auto.
            destruct H22 as [F0]. 
            destruct H3 as [lo0].
            rewrite H3 in H; inversion H; subst; auto.
            rewrite <- H5 in H10. inversion H10; subst; auto.
            rewrite H13 in H0; inversion H0; subst; auto.
            remember ( (update_typing empty_context arg_id0 (classTy arguT))) as gamma0.
            apply T_config_ctns with (OpaqueLabeledTy (classTy returnT0)) gamma0; auto.

            apply T_ctn_fs with (classTy returnT0); auto.
            admit.
            intro contra. inversion contra.
            intro contra. inversion contra.
            apply T_ctn_list with fs lb sf Gamma' T'
                                  T2; auto.
            apply T_ctn_sequential_exec with T2 T2; auto.
            intros.
            split; auto.
            intros.
            destruct H14. 
            pose proof (H15 top fs') as Hy; intuition.
            intros.
            destruct H14.
            pose proof (H19 top fs') as Hy; intuition.
            try (inconsist).
      
-  (*(Container t' nil (join_label lb0 lx) (sf_update empty_stack_frame arg_id v))*)
   inversion H_typing; subst; auto.
    ++ inversion H9; subst; auto. 
       +++  inversion H12; subst;auto.
            inversion H6; subst; auto.
            destruct H20 as [F0]. 
            destruct H0 as [lo0].
            rewrite H0 in H; inversion H; subst; auto.
            rewrite <- H5 in H8; inversion H8; subst; auto.
            rewrite H11 in H4. inversion H4. subst; auto.
            remember ( (update_typing empty_context arg_id0 (classTy arguT))) as gamma0.
            apply T_config_ctns with (OpaqueLabeledTy (classTy returnT0)) gamma0; auto.
            apply T_ctn_fs with (classTy returnT0); auto.
            admit.
            intro contra. inversion contra.
            apply T_ctn_list with fs lb sf empty_context T'
                                  (OpaqueLabeledTy (classTy returnT0)); auto.
            apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT0)); auto.
       +++  inversion H14; subst; auto. 
            inversion H6; subst; auto.
            destruct H20 as [F0]. 
            destruct H0 as [lo0].
            rewrite H0 in H; inversion H; subst; auto.
            rewrite <- H5 in H8. inversion H8; subst; auto.
            rewrite H11 in H4; inversion H4; subst; auto.
            remember ( (update_typing empty_context arg_id0 (classTy arguT))) as gamma0.
            apply T_config_ctns with (OpaqueLabeledTy (classTy returnT0)) gamma0; auto.

            apply T_ctn_fs with (classTy returnT0); auto.
            admit.
            intro contra. inversion contra.
            intro contra. inversion contra.
            apply T_ctn_list with fs lb sf empty_context T'
                                  T1; auto.
            apply T_ctn_sequential_exec with T1 T1; auto.
            intros.
            destruct H12; subst; auto.
            (*inversion H1.   
            pose proof (H12 top fs') as Hy; intuition.
            try (inconsist). *) admit. 
    ++ inversion H8; subst; auto. 
       +++  inversion H14; subst; auto. 
            inversion H6; subst; auto.
            destruct H22 as [F0]. 
            destruct H0 as [lo0].
            rewrite H0 in H; inversion H; subst; auto.
            rewrite <- H5 in H9. inversion H9; subst; auto.
            rewrite H13 in H4; inversion H4; subst; auto.
            remember ( (update_typing empty_context arg_id0 (classTy arguT))) as gamma0.
            apply T_config_ctns with (OpaqueLabeledTy (classTy returnT0)) gamma0; auto.
            apply T_ctn_fs with (classTy returnT0); auto.
            admit.
            intro contra. inversion contra.
            apply T_ctn_list with fs lb sf Gamma' T'
                                  (OpaqueLabeledTy (classTy returnT0)); auto.
            apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT0)); auto.
       +++  inversion H16; subst; auto. 
            inversion H6; subst; auto.
            destruct H22 as [F0]. 
            destruct H0 as [lo0].
            rewrite H0 in H; inversion H; subst; auto.
            rewrite <- H5 in H9. inversion H9; subst; auto.
            rewrite H13 in H4; inversion H4; subst; auto.
            remember ( (update_typing empty_context arg_id0 (classTy arguT))) as gamma0.
            apply T_config_ctns with (OpaqueLabeledTy (classTy returnT0)) gamma0; auto.
            apply T_ctn_fs with (classTy returnT0); auto.
            admit.
            intro contra. inversion contra.
            intro contra. inversion contra.
            apply T_ctn_list with fs lb sf Gamma' T'
                                  T2; auto.
            apply T_ctn_sequential_exec with T2 T2; auto.
            (*
            intros.
            destruct H14; subst; auto.
            inversion H1.
            pose proof (H14 top fs') as Hy; intuition.
            try (inconsist).
            *) admit. admit.


(*new expression*)
- inversion H_typing; subst;auto.
  + inversion H6; subst; auto.
    ++ inversion H8; subst; auto. 
       apply T_config_nil. 
       apply T_ctn_fs with (classTy cls_name); auto.
       destruct H4 as [cls_def0].
       destruct H0 as [field_defs0].
       destruct H0 as [method_defs0].
       destruct H0.  
       apply T_ObjId with cls_def0; auto.  
       admit.
       admit.
       admit.
       admit. 
   ++ inversion H11; subst; auto. 
      apply T_config_nil. 
      apply T_ctn_fs with (classTy cls_name); auto.
      destruct H4 as [cls_def0].
      destruct H0 as [field_defs0].
      destruct H0 as [method_defs0].
      destruct H0.  
      apply T_ObjId with cls_def0; auto.
      admit. 
      admit.
      admit.
      intro contra; inversion contra.       
      admit. 
  + inversion H5; subst; auto.
    ++ inversion H11; subst; auto. 
       apply T_config_ctns with (OpaqueLabeledTy (classTy cls_name)) Gamma'. 
       apply T_ctn_fs with (classTy cls_name); auto.
       destruct H4 as [cls_def0].
       destruct H0 as [field_defs0].
       destruct H0 as [method_defs0].
       destruct H0.  
       apply T_ObjId with cls_def0; auto.  
       admit.
       admit.
       admit.
       admit.
       intro contra; inversion contra.
       admit. 
       
    ++ inversion H13; subst; auto. 
       apply T_config_ctns with (OpaqueLabeledTy (classTy cls_name)) Gamma'. 
       apply T_ctn_fs with (classTy cls_name); auto.
       destruct H4 as [cls_def0].
       destruct H0 as [field_defs0].
       destruct H0 as [method_defs0].
       destruct H0.  
       apply T_ObjId with cls_def0; auto.  
       admit.
       admit.
       admit.
       intro contra; inversion contra. 
       admit.
       intro contra; inversion contra.
       admit. 

       
(*(labelData hole lo :: fs0)*)
  -  inversion H_typing; subst; auto.
     + apply T_config_nil; auto.
       inversion H7; subst; auto.
       ++ inversion H9; subst; auto.
          apply T_ctn_fs with  T ; auto.
          eauto using fs_has_type. 
          
       ++ inversion H11; subst; auto.
          apply T_ctn_fs with  T ; auto.
          apply T_fs_labelData with T1; auto.
          intros. 
          destruct H9; subst; auto.
          pose proof (H4 top fs') as Hy. intuition.
          try (inconsist).
          
          apply H9; auto. 

     + apply T_config_ctns with T0 Gamma'; auto.
       inversion H6; subst; auto.
       ++ inversion H11; subst; auto.
          apply T_ctn_fs with T0 ; auto.
          eauto using fs_has_type.
       ++ inversion H13; subst; auto.
          apply T_ctn_fs with T0 ; auto.
          apply T_fs_labelData with T2; auto.
          intros. 
          destruct H11; subst; auto.
          pose proof (H4 top fs') as Hy. intuition.
          try (inconsist).

          apply H11; auto.


(*label data t lo*)
 - inversion H_typing; subst; auto. 
   + apply T_config_nil.
     inversion H7; subst; auto.  
     inversion H13; subst; auto; try (inconsist_hole_free).
      ++ destruct fs.
         +++ apply T_ctn_fs with (LabelelTy T0); auto.
             intro contra; inversion contra.
             intuition. rewrite H0 in H15.
             inversion H15; subst; auto.             
         +++ case_eq (hole_free t); intro.
             ++++
               apply T_ctn_sequential_exec with  (LabelelTy T0)  T1; auto.
               split; auto.
               intros. 
               inversion H1; subst; auto.              
             ++++
               apply H16 with t fs in H0; subst; auto.
               apply T_ctn_fs with (LabelelTy T0) ; auto.
               intro contra. inversion contra.

      ++ destruct H9. 
         pose proof (H1 (labelData hole lo) fs) as Hy;
           simpl in Hy; intuition.

    +  apply T_config_ctns with T0 Gamma'; auto.
       inversion H6; subst; auto.  
     inversion H15; subst; auto; try (inconsist_hole_free).
      ++ destruct fs.
         +++ apply T_ctn_sequential_exec with (LabelelTy T1)  T2; auto.
             split; auto.
             intros. inversion H0. 
         +++ case_eq (hole_free t); intro.
             ++++
               apply T_ctn_sequential_exec with  (LabelelTy T1)  T2; auto.
               split; auto.
               intros. inversion H1; subst; auto.
             ++++
               apply H18 with t fs in H0; subst; auto.
               apply T_ctn_fs with  (LabelelTy T1) ; auto.
               intro contra. inversion contra.

      ++ destruct H11. 
         pose proof (H1 (labelData hole lo ) fs) as Hy;
           simpl in Hy; intuition.

- (* v_l v lo *)
   inversion H_typing; subst; auto.
   + apply T_config_nil; auto.
     inversion H7; subst; auto.
     ++ inversion H9; subst; auto.
        apply T_ctn_fs with ((LabelelTy T)) ; auto.          
       ++ inversion H11; subst; auto.
          apply T_ctn_sequential_exec with (LabelelTy T) T1 ; auto.
          
   + apply T_config_ctns with T0 Gamma'; auto.
     inversion H6; subst; auto.
     ++ inversion H11; subst; auto.
        apply T_ctn_fs with ((LabelelTy T0)) ; auto.          
     ++ inversion H13; subst; auto.
        apply T_ctn_sequential_exec with (LabelelTy T0) T2 ; auto.


        
 (*  (unlabel hole :: fs0)  *)
- inversion H_typing; subst; auto.
  + apply T_config_nil; auto.
    inversion H7; subst; auto.
    ++ inversion H9; subst; auto.
       apply T_ctn_fs with (LabelelTy T0) ; auto.
       intro contra; inversion contra. 
       eauto using fs_has_type.           
    ++ inversion H11; subst; auto.
       apply T_ctn_fs with  (LabelelTy T0) ; auto.
       intro contra; inversion contra.       
       apply T_fs_unlabel with T1; auto.
       intros. 
       destruct H9; subst; auto.
       pose proof (H4 top fs') as Hy. intuition.
       try (inconsist).
       apply H9; auto.
  + apply T_config_ctns with T0 Gamma'; auto.
    inversion H6; subst; auto.
    ++ inversion H11; subst; auto.
       apply T_ctn_fs with (LabelelTy T1) ; auto.
       intro contra; inversion contra. 
       eauto using fs_has_type.
    ++ inversion H13; subst; auto.
       apply T_ctn_fs with  (LabelelTy T1) ; auto.
       intro contra; inversion contra. 
       apply T_fs_unlabel with T2; auto.
       intros. 
       destruct H11; subst; auto.
       pose proof (H4 top fs') as Hy. intuition.
       try (inconsist).
       apply H11; auto. 

(*  (unlabel t)  *)
- inversion H_typing; subst; auto. 
  + apply T_config_nil.
    inversion H7; subst; auto.  
    inversion H13; subst; auto; try (inconsist_hole_free).
    ++ destruct fs.
       +++ apply T_ctn_sequential_exec with T T1; auto.
           split; auto. intros. inversion H0; subst; auto.
           inversion H3; auto.           
       +++ case_eq (hole_free t); intro.
           ++++
             apply T_ctn_sequential_exec with T  T1; auto.
             split; auto.
             intros. inversion H1; subst; auto.
             inversion H3; auto.
           ++++
             apply H14 with t fs in H0; subst; auto.
             apply T_ctn_fs with T ; auto.
             inversion H3; auto.
             inversion H3; subst; auto.

      ++ destruct H9. 
         pose proof (H1 (unlabel hole) fs) as Hy;
           simpl in Hy; intuition.

    +  apply T_config_ctns with T0 Gamma'; auto.
       inversion H6; subst; auto.  
       inversion H15; subst; auto; try (inconsist_hole_free).
      ++ destruct fs.
         +++ apply T_ctn_sequential_exec with T0  T2; auto.
             split; auto.
             intros. inversion H0. 
             inversion H3; subst; auto.
         +++ case_eq (hole_free t); intro.
             ++++
               apply T_ctn_sequential_exec with T0  T2; auto.
               split; auto.
               intros. inversion H1; subst; auto.
               inversion H3; subst; auto.
             ++++
               apply H16 with t fs in H0; subst; auto.
               apply T_ctn_fs with  T0 ; auto.
               inversion H3; subst; auto.
               inversion H3; subst; auto.

      ++ destruct H11. 
         pose proof (H1 (unlabel hole ) fs) as Hy;
           simpl in Hy; intuition.

- (*   (join_label lb0 lo)   *)
  inversion H_typing; subst; auto.
   + apply T_config_nil; auto.
     inversion H7; subst; auto.
     ++ inversion H9; subst; auto.
        inversion H1; subst; auto. 
        apply T_ctn_fs with T0 ; auto.          
     ++ inversion H11; subst; auto.
        apply T_ctn_sequential_exec with T0 T1 ; auto.
        inversion H1; subst; auto.
          
   + apply T_config_ctns with T0 Gamma'; auto.
     inversion H5; subst; auto.
     ++ inversion H11; subst; auto.
        inversion H1; subst; auto.
        apply T_ctn_fs with T1 ; auto.          
     ++ inversion H13; subst; auto.
        apply T_ctn_sequential_exec with T1 T2 ; auto.
        inversion H1; subst; auto.


    
(* (labelOf hole :: fs0) *)
- inversion H_typing; subst; auto.
  + apply T_config_nil; auto.
    inversion H7; subst; auto.
    ++ inversion H9; subst; auto.
       apply T_ctn_fs with (LabelelTy T) ; auto.
       intro contra; inversion contra. 
       eauto using fs_has_type.           
    ++ inversion H11; subst; auto.
       apply T_ctn_fs with  (LabelelTy T) ; auto.
       intro contra; inversion contra.       
       apply T_fs_labelOf with T1; auto.
       eauto using tm_has_type.
       intros. 
       destruct H9; subst; auto.
       pose proof (H4 top fs') as Hy. intuition.
       try (inconsist).
       apply H9; auto.
  + apply T_config_ctns with T0 Gamma'; auto.
    inversion H6; subst; auto.
    ++ inversion H11; subst; auto.
       apply T_ctn_fs with (LabelelTy T0) ; auto.
       intro contra; inversion contra. 
       eauto using fs_has_type.
    ++ inversion H13; subst; auto.
       apply T_ctn_fs with  (LabelelTy T0) ; auto.
       intro contra; inversion contra. 
       apply T_fs_labelOf with T2; auto.
       eauto using tm_has_type.
       intros. 
       destruct H11; subst; auto.
       pose proof (H4 top fs') as Hy. intuition.
       try (inconsist).
       apply H11; auto. 

(* (labelOf t) *)
- inversion H_typing; subst; auto. 
  + apply T_config_nil.
    inversion H7; subst; auto.  
    inversion H13; subst; auto; try (inconsist_hole_free).
    ++ destruct fs.
       +++ apply T_ctn_sequential_exec with  LabelTy T1; auto.
           split; auto.
           intros. inversion H0.
           induction H; 
             inversion H9; subst; auto.
           eauto using tm_has_type.
           eauto using tm_has_type.
       +++ case_eq (hole_free t); intro.
           ++++
             apply T_ctn_sequential_exec with LabelTy  T1; auto.
             split; auto.
             intros. inversion H1; subst; auto. 
             induction H; 
             inversion H9; subst; auto.
             eauto using tm_has_type.
             eauto using tm_has_type.
           ++++
             apply H14 with t fs in H0; subst; auto.
             apply T_ctn_fs with LabelTy ; auto.
             induction H; 
             inversion H9; subst; auto.
             eauto using tm_has_type.
             eauto using tm_has_type.
             intro contra; inversion contra. 

      ++ destruct H9. 
         pose proof (H1 (labelOf hole) fs) as Hy;
           simpl in Hy; intuition.

    +  apply T_config_ctns with T0 Gamma'; auto.
       inversion H6; subst; auto.  
       inversion H15; subst; auto; try (inconsist_hole_free).
       ++ destruct fs.
          +++ apply T_ctn_sequential_exec with LabelTy  T2; auto.
              split; auto.
              intros. inversion H0. 
              induction H; 
                inversion H11; subst; auto.
              eauto using tm_has_type.
              eauto using tm_has_type.
         +++ case_eq (hole_free t); intro.
             ++++
             apply T_ctn_sequential_exec with LabelTy   T2; auto.
             split; auto.
             intros. 
             inversion H1; subst; auto.
             induction H; 
                inversion H11; subst; auto.
             eauto using tm_has_type.
             eauto using tm_has_type.
             ++++
               apply H16 with t fs in H0; subst; auto.
               apply T_ctn_fs with LabelTy ; auto.
               induction H; 
                inversion H11; subst; auto.
              eauto using tm_has_type.
              eauto using tm_has_type.
              intro contra; inversion contra. 

      ++ destruct H11. 
         pose proof (H1 (labelOf hole ) fs) as Hy;
           simpl in Hy; intuition.

- (* l lo *)
  inversion H_typing; subst; auto.
  + apply T_config_nil; auto.
    inversion H7; subst; auto.
    ++ inversion H9; subst; auto.
       inversion H1; subst; auto. 
       apply T_ctn_fs with LabelTy; auto.          
    ++ inversion H11; subst; auto.
       apply T_ctn_sequential_exec with LabelTy T1 ; auto.
          
  + apply T_config_ctns with T0 Gamma'; auto.
    inversion H6; subst; auto.
    ++ inversion H11; subst; auto.
       inversion H1; subst; auto.
       apply T_ctn_fs with LabelTy ; auto.          
    ++ inversion H13; subst; auto.
       apply T_ctn_sequential_exec with LabelTy T2 ; auto.


          
(* (unlabelOpaque hole :: fs0) *)
- inversion H_typing; subst; auto.
  + apply T_config_nil; auto.
    inversion H7; subst; auto.
    ++ inversion H9; subst; auto.
       apply T_ctn_fs with (OpaqueLabeledTy T0) ; auto.
       intro contra; inversion contra. 
       eauto using fs_has_type.           
    ++ inversion H11; subst; auto.
       apply T_ctn_fs with  (OpaqueLabeledTy T0) ; auto.
       intro contra; inversion contra.       
       apply T_fs_unlabelOpaque with T1; auto.
       intros. 
       destruct H9; subst; auto.
       pose proof (H4 top fs') as Hy. intuition.
       try (inconsist).
       apply H9; auto.
  + apply T_config_ctns with T0 Gamma'; auto.
    inversion H6; subst; auto.
    ++ inversion H11; subst; auto.
       apply T_ctn_fs with (OpaqueLabeledTy T1) ; auto.
       intro contra; inversion contra. 
       eauto using fs_has_type.
    ++ inversion H13; subst; auto.
       apply T_ctn_fs with  (OpaqueLabeledTy T1) ; auto.
       intro contra; inversion contra. 
       apply T_fs_unlabelOpaque with T2; auto.
       intros. 
       destruct H11; subst; auto.
       pose proof (H4 top fs') as Hy. intuition.
       try (inconsist).
       apply H11; auto. 


(* (unlabelOpaque t) *)
- inversion H_typing; subst; auto. 
  + apply T_config_nil.
    inversion H7; subst; auto.  
    inversion H13; subst; auto; try (inconsist_hole_free).
    ++ destruct fs.
       +++ apply T_ctn_sequential_exec with T T1; auto.
           split; auto.
           intros. inversion H0.
           inversion H3; subst; auto. 
       +++ case_eq (hole_free t); intro.
           ++++
             apply T_ctn_sequential_exec with T  T1; auto.
             split ; auto. intros.
             inversion H1; subst; auto.
             inversion H3; subst; auto. 
           ++++
             apply H14 with t fs in H0; subst; auto.
             apply T_ctn_fs with T ; auto.
             inversion H3; subst; auto.
             inversion H3; subst; auto. 

      ++ destruct H9. 
         pose proof (H1 (unlabelOpaque hole) fs) as Hy;
           simpl in Hy; intuition.

    +  apply T_config_ctns with T0 Gamma'; auto.
       inversion H6; subst; auto.  
     inversion H15; subst; auto; try (inconsist_hole_free).
      ++ destruct fs.
         +++ apply T_ctn_sequential_exec with T0  T2; auto.
             split; auto.
             intros. inversion H0.
             inversion H3; subst; auto.
         +++ case_eq (hole_free t); intro.
             ++++
             apply T_ctn_sequential_exec with T0  T2; auto.
             split; auto.
             intros. 
             inversion H1; subst; auto.
             inversion H3; subst; auto. 
             ++++
               apply H16 with t fs in H0; subst; auto.
               apply T_ctn_fs with  T0 ; auto;
               inversion H3; subst; auto.

      ++ destruct H11. 
         pose proof (H1 (unlabelOpaque hole ) fs) as Hy;
           simpl in Hy; intuition.

- (*   (join_label lb0 lo)   *)
  inversion H_typing; subst; auto.
   + apply T_config_nil; auto.
     inversion H7; subst; auto.
     ++ inversion H9; subst; auto.
        inversion H1; subst; auto. 
        apply T_ctn_fs with T0 ; auto.          
     ++ inversion H11; subst; auto.
        apply T_ctn_sequential_exec with T0 T1 ; auto.
        inversion H1; subst; auto.
          
   + apply T_config_ctns with T0 Gamma'; auto.
     inversion H5; subst; auto.
     ++ inversion H11; subst; auto.
        inversion H1; subst; auto.
        apply T_ctn_fs with T1 ; auto.          
     ++ inversion H13; subst; auto.
        apply T_ctn_sequential_exec with T1 T2 ; auto.
        inversion H1; subst; auto.


(*(Assignment id0 hole :: fs0)  *)
- inversion H_typing; subst; auto.
  + apply T_config_nil; auto.
    inversion H7; subst; auto.
    ++ inversion H9; subst; auto.
       intuition. 
    ++ inversion H11; subst; auto.
       inversion H2.
  + apply T_config_ctns with T0 Gamma'; auto.
    inversion H6; subst; auto.
    ++ inversion H11; subst; auto.
       intuition.
    ++ inversion H13; subst; auto.
       apply T_ctn_fs with T0 ; auto.
       apply T_fs_assignment with T2; auto.
       eauto using tm_has_type.
       intros; subst; auto.
       destruct H11.       
       apply H1 with fs'; auto.
       apply H11; auto. 
       

(*(Assignment id0 t)*)
- inversion H_typing; subst; auto. 
  + apply T_config_nil.
    inversion H7; subst; auto.  
    inversion H13; subst; auto; try (inconsist_hole_free).
    ++ destruct fs.
       +++ apply T_ctn_sequential_exec with voidTy T1; auto.
           eauto using tm_has_type.
       +++ case_eq (hole_free t); intro.
           ++++
             apply T_ctn_sequential_exec with voidTy  T1; auto.
             eauto using tm_has_type.
           ++++
             pose proof (H16 t fs) as Hy; intuition.
             try (inconsist).

      ++ destruct H9. 
         pose proof (H1 (Assignment id hole) fs) as Hy;
           simpl in Hy; intuition.

    +  apply T_config_ctns with T0 Gamma'; auto.
       inversion H6; subst; auto.  
     inversion H15; subst; auto; try (inconsist_hole_free).
      ++ destruct fs.
         +++ apply T_ctn_sequential_exec with voidTy  T2; auto.
             eauto using tm_has_type.
         +++ case_eq (hole_free t); intro.
             ++++
               apply T_ctn_sequential_exec with voidTy  T2; auto.
               eauto using tm_has_type.               
             ++++
               apply T_ctn_sequential_exec with voidTy  T2; auto.
               eauto using tm_has_type.
      ++ destruct H11. 
         pose proof (H1 (Assignment id hole) fs) as Hy;
           simpl in Hy; intuition.

- (* Skip*)
  inversion H_typing; subst; auto.
   + apply T_config_nil; auto.
     inversion H7; subst; auto.
     ++ inversion H9; subst; auto.
        inversion H2. 
     ++ inversion H11; subst; auto.
        inversion H2. 
          
   + apply T_config_ctns with T0 Gamma'; auto.
     inversion H5; subst; auto.
     ++ inversion H11; subst; auto.
        intuition.
     ++ inversion H13; subst; auto.
        apply T_ctn_sequential_exec with voidTy T2 ; auto.
        (*well typed sf value*)
        apply well_typed_sf; auto; intros. 
        case_eq (beq_id id x);intro.
        unfold sf_update in H1. rewrite H3 in H1.
        inversion H1; subst; auto.
        apply beq_equal in H3.  subst; auto.
        rewrite H0 in H2; inversion H2; subst; auto.

        unfold sf_update in H1. rewrite H3 in H1.
        inversion H14; subst; auto.
        apply H4 with x; auto. 


(* (FieldWrite hole f e2 :: fs0)*)
- inversion H_typing; subst; auto.
  + apply T_config_nil; auto.
    inversion H7; subst; auto.
    ++ inversion H9; subst; auto.
       apply T_ctn_fs with (classTy clsT) ; auto.
       eauto using fs_has_type.           
    ++ inversion H11; subst; auto.
       apply T_ctn_fs with  (classTy clsT) ; auto.
       intro contra; inversion contra.       
       apply T_fs_FieldWrite1 with  cls_def cls' T1; auto.
       eauto using tm_has_type.           
       intros. 
       destruct H9; subst; auto.
       apply H2 with fs'; auto.
       apply H9; auto.

  + apply T_config_ctns with T0 Gamma'; auto.
    inversion H6; subst; auto.
    ++ inversion H11; subst; auto.
       apply T_ctn_fs with (classTy clsT) ; auto.
       eauto using fs_has_type.
    ++ inversion H13; subst; auto.
       apply T_ctn_fs with (classTy clsT); auto.
       intro contra; inversion contra. 
       apply T_fs_FieldWrite1 with  cls_def cls' T2; auto.
       eauto using tm_has_type.     
       intros.
       destruct H11; subst; auto.
       apply H2 with fs'; auto.
       apply H11; auto. 


(*FieldWrite v f e2)*)
- inversion H_typing; subst; auto. 
  + apply T_config_nil.
    inversion H7; subst; auto.  
    inversion H13; subst; auto; try (inconsist_hole_free).
    ++ destruct fs.
       +++ apply T_ctn_sequential_exec with voidTy T1; auto.
           eauto using tm_has_type.
       +++ case_eq (hole_free t); intro.
           ++++
             apply T_ctn_sequential_exec with voidTy  T1; auto.
             eauto using tm_has_type.
           ++++
             pose proof (H19 t fs) as Hy; intuition.
             try (inconsist).

    ++ inversion H_valid_config; subst;auto.
       inversion H15; subst; auto.
       inversion H4; subst; auto.
       inversion H2; subst; auto; try (inconsist_hole_free).

    ++ destruct H9. 
       pose proof (H1 (FieldWrite hole f e2) fs) as Hy; intuition.

  + apply T_config_ctns with T0 Gamma'; auto.
    inversion H6; subst; auto.  
    inversion H15; subst; auto; try (inconsist_hole_free).
    ++ destruct fs.
       +++ apply T_ctn_sequential_exec with voidTy T0; auto.
           eauto using tm_has_type.
       +++ case_eq (hole_free t); intro.
           ++++
             apply T_ctn_sequential_exec with voidTy  T0; auto.
             eauto using tm_has_type.
           ++++
             pose proof (H21 t fs) as Hy; intuition.
             try (inconsist).

    ++ inversion H_valid_config; subst;auto.
       inversion H17; subst; auto.
       inversion H4; subst; auto.
       inversion H2; subst; auto; try (inconsist_hole_free).

    ++ destruct H11. 
       pose proof (H1 (FieldWrite hole f e2) fs) as Hy; intuition.


(* (Container e2 (FieldWrite v f hole :: fs) lb sf) *)
- inversion H_typing; subst; auto.
  + apply T_config_nil; auto.
    inversion H9; subst; auto.
    ++ inversion H11; subst; auto.
       apply T_ctn_fs with (classTy cls') ; auto.
       eauto using fs_has_type.           
    ++ inversion H13; subst; auto.
       apply T_ctn_fs with (classTy cls') ; auto.
       intro contra; inversion contra.       
       apply T_fs_FieldWrite2 with  cls_def clsT T1; auto.
       eauto using tm_has_type.           
       intros. 
       destruct H11; subst; auto.
       apply H4 with fs'; auto.
       apply H11; auto. 

  + apply T_config_ctns with T0 Gamma'; auto.
    inversion H8; subst; auto.
    ++ inversion H13; subst; auto.
       apply T_ctn_fs with (classTy cls') ; auto.
       eauto using fs_has_type.
    ++ inversion H15; subst; auto.
       apply T_ctn_fs with (classTy cls'); auto.
       intro contra; inversion contra. 
       apply T_fs_FieldWrite2 with  cls_def clsT T2; auto.
       eauto using tm_has_type.     
       intros.
       destruct H13; subst; auto.
       apply H4 with fs'; auto.
       apply H13; auto. 
       

(*(Container (FieldWrite v1 f v2)*)
- inversion H_typing; subst; auto.
  + apply T_config_nil.
    inversion H8; subst;auto.
    ++ inversion H14; subst; auto; (try inconsist_hole_free).
       inversion H9; subst; auto.
       apply value_is_hole_free in H0.
       rewrite H0 in H2; intuition.
       inversion H11; subst; auto.      
       apply value_is_hole_free in H0.
       rewrite H0 in H2; intuition.
       inversion H15; subst; auto.      
       apply value_is_hole_free in H0.
       rewrite H0 in H2; intuition.
       destruct fs.
           +++ apply T_ctn_sequential_exec with voidTy
                                                T1; auto.
               eauto using tm_has_type.               
           +++ case_eq (hole_free t); intro.
             ++++
               apply T_ctn_sequential_exec with voidTy
                                                T1; auto.           
               eauto using tm_has_type.
             ++++
               pose proof (H20 t fs); intuition.
               try (inconsist).
           
        ++ destruct H10. 
         pose proof (H2 (FieldWrite v1 f hole ) fs) as Hy;
           simpl in Hy; intuition.
         apply value_is_hole_free in H0.
         rewrite H0 in H3; intuition.
         
  + apply T_config_ctns with T0 Gamma'; subst; auto. 
    inversion H7; subst;auto.
    ++ inversion H16; subst; auto; (try inconsist_hole_free).
       inversion H11; subst; auto.
       apply value_is_hole_free in H0.
       rewrite H0 in H2; intuition.
       inversion H13; subst; auto.      
       apply value_is_hole_free in H0.
       rewrite H0 in H2; intuition.
       inversion H17; subst; auto.      
       apply value_is_hole_free in H0.
       rewrite H0 in H2; intuition.
       destruct fs.
       +++ apply T_ctn_sequential_exec with voidTy
                                                T0; auto.
           eauto using tm_has_type.               
       +++ case_eq (hole_free t); intro.
           ++++
             apply T_ctn_sequential_exec with voidTy
                                                T0; auto.
             eauto using tm_has_type.
           ++++
             apply T_ctn_sequential_exec with voidTy
                                                T0; auto.
             eauto using tm_has_type.
    ++ destruct H12. 
       pose proof (H2 (FieldWrite v1 f hole) fs) as Hy;
         simpl in Hy; intuition.
       apply value_is_hole_free in H0.
       rewrite H0 in H3; intuition.

(* field write normal*)
- inversion H_typing; subst; auto.
  inversion H8; subst; auto.
  inversion H11; subst; auto.
  + apply T_config_nil; auto.
    apply T_ctn_fs with (voidTy); auto.
  + apply T_config_nil; auto.
    apply T_ctn_sequential_exec with voidTy T1; auto.
    split; auto.
    inversion H13; subst; auto. 
    apply H11; auto.
    intros. destruct H11.
    apply H4 with fs'; auto. 
  + inversion H7; subst; auto.
    inversion H13; subst; auto. 
    ++ apply T_config_ctns with ((OpaqueLabeledTy T')) Gamma'; auto.
       apply T_ctn_fs with voidTy; auto. 

    ++ apply T_config_ctns with ((OpaqueLabeledTy T')) Gamma'; auto.
       apply T_ctn_sequential_exec with voidTy T2; auto.
       split; auto.
       inversion H15; subst; auto.
       apply H13; auto.
       intros.
       destruct H13. apply H4 with fs'. auto. 

(* field write opaque *)
- inversion H_typing; subst; auto.
  inversion H8; subst; auto.
  inversion H11; subst; auto.
  + apply T_config_nil; auto.
    apply T_ctn_fs with (voidTy); auto.
    admit. admit. 
  + apply T_config_nil; auto.
    apply T_ctn_sequential_exec with voidTy T1; auto.
    split; auto. inversion H13; subst; auto. apply H11; auto.
    intros. destruct H11. apply H4 with fs'; auto.
    admit. admit. 
  + inversion H7; subst; auto.
    inversion H13; subst; auto. 
    ++ apply T_config_ctns with ((OpaqueLabeledTy T')) Gamma'; auto.
       apply T_ctn_fs with voidTy; auto.
       admit. admit.
       admit. 

    ++ apply T_config_ctns with ((OpaqueLabeledTy T')) Gamma'; auto.
       apply T_ctn_sequential_exec with voidTy T2; auto.
       split; auto. inversion H15; subst; auto. apply H13; auto.
       intros. destruct H13. apply H4 with fs'; auto.
       admit. admit. admit. 


(* if with hole*)
- inversion H_typing; subst; auto.
  + apply T_config_nil; auto.
    inversion H7; subst; auto.
    ++ inversion H9; subst; auto.
       apply T_ctn_fs with boolTy ; auto.
       intro contra; inversion contra.
       apply T_fs_if with T0 T0; auto.
    ++ inversion H11; subst; auto.
       apply T_ctn_fs with boolTy; auto.
       intro contra; inversion contra.       
       apply T_fs_if with T0 T1; auto.
       intros. 
       destruct H9; subst; auto.
       split; auto; intro.
       pose proof (H2 top fs'); intuition.
       try (inconsist).
       
       pose proof (H2 top fs'); intuition.
       apply H9; auto.

  + apply T_config_ctns with T0 Gamma'; auto.
    inversion H6; subst; auto.
    ++ inversion H11; subst; auto.
       apply T_ctn_fs with boolTy ; auto.
       intro contra; inversion contra. 
       apply T_fs_if with T1 T1; auto.         
    ++ inversion H13; subst; auto.
       apply T_ctn_fs with boolTy; auto.
       intro contra; inversion contra.       
       apply T_fs_if with T1 T2; auto.
       intros.
       destruct H11. 
       split; auto; intro.
       pose proof (H2 top fs'); intuition.
       try (inconsist).
       pose proof (H2 top fs'); intuition.
       apply H11; auto. 


(* if guard s1 s2*)
- inversion H_typing; subst; auto. 
  + apply T_config_nil.
    inversion H7; subst; auto.  
    inversion H13; subst; auto; try (inconsist_hole_free).
    ++ destruct fs.
       +++ apply T_ctn_sequential_exec with T T1; auto.
           split; auto.
           intros. inversion H0. 
           inversion H14; subst; auto.
       +++ case_eq (hole_free t); intro.
           ++++
             apply T_ctn_sequential_exec with T  T1; auto.
             split; auto.
             intros. inversion H1; subst; auto.
             inversion H14; subst; auto.
           ++++
             apply H16 with t fs in H0; subst; auto.             
             inversion H14; subst; auto.
             induction T; subst; auto.
             apply T_ctn_fs with (classTy c) ; auto; intro contra; inversion contra.
             apply T_ctn_fs with boolTy ; auto; intro contra; inversion contra.
             apply T_ctn_fs with LabelTy ; auto; intro contra; inversion contra.
             apply T_ctn_fs with (LabelelTy T) ; auto; intro contra; inversion contra.
             apply T_ctn_fs with (OpaqueLabeledTy T) ; auto; intro contra; inversion contra.
             apply T_ctn_sequential_exec with voidTy  voidTy; auto.
             split; auto.
             intros. inversion H0. 
             destruct H16 with t fs; auto.  intuition.
             inversion H0; subst; auto. 
             apply T_ctn_fs with (ArrowTy T1 T2) ; auto; intro contra; inversion contra.

      ++ destruct H9. 
         pose proof (H1 (If hole s1 s2) fs) as Hy;
           simpl in Hy; intuition.

    +  apply T_config_ctns with T0 Gamma'; auto.
       inversion H6; subst; auto.  
       inversion H15; subst; auto; try (inconsist_hole_free).
       ++ destruct fs.
          +++ apply T_ctn_sequential_exec with T0  T2; auto.
              split; auto.
              intros. inversion H0. 
              inversion H16; subst; auto. 
          +++ case_eq (hole_free t); intro.
              ++++
                apply T_ctn_sequential_exec with T0  T2; auto.
                split; auto.
                intros. inversion H1; subst; auto.
                inversion H16; subst; auto. 
              ++++
                apply H18 with t fs in H0; subst; auto.
                inversion H16; subst; auto.
                induction T0; subst; auto.                
                apply  T_ctn_fs with (classTy c); auto; intro contra; inversion contra.
                apply T_ctn_fs with boolTy ; auto; intro contra; inversion contra.
                apply T_ctn_fs with LabelTy ; auto; intro contra; inversion contra.
                apply T_ctn_fs with (LabelelTy T0) ; auto; intro contra; inversion contra.
                apply T_ctn_fs with (OpaqueLabeledTy T0) ; auto; intro contra; inversion contra.
                apply T_ctn_sequential_exec with voidTy  voidTy; auto.
                split; auto.
                intros. inversion H0; subst; auto.
                destruct H18 with top fs'; auto. 
                apply T_ctn_fs with (ArrowTy T0_1 T0_2) ; auto; intro contra; inversion contra.

      ++ destruct H11. 
         pose proof (H1 (If hole s1 s2) fs) as Hy;
           simpl in Hy; intuition.

- (*   B_true   *)
  inversion H_typing; subst; auto.
   + apply T_config_nil; auto.
     inversion H6; subst; auto.
     ++ inversion H8; subst; auto.
        apply T_ctn_fs with T0 ; auto.          
     ++ inversion H10; subst; auto.
        apply T_ctn_sequential_exec with T0 T1 ; auto.
          
   + apply T_config_ctns with T0 Gamma'; auto.
     inversion H5; subst; auto.
     ++ inversion H10; subst; auto.
        apply T_ctn_fs with T1 ; auto.          
     ++ inversion H12; subst; auto.
        apply T_ctn_sequential_exec with T1 T2 ; auto.

- (*   B_false   *)
  inversion H_typing; subst; auto.
   + apply T_config_nil; auto.
     inversion H6; subst; auto.
     ++ inversion H8; subst; auto.
        apply T_ctn_fs with T0 ; auto.          
     ++ inversion H10; subst; auto.
        apply T_ctn_sequential_exec with T0 T1 ; auto.
          
   + apply T_config_ctns with T0 Gamma'; auto.
     inversion H5; subst; auto.
     ++ inversion H10; subst; auto.
        apply T_ctn_fs with T1 ; auto.          
     ++ inversion H12; subst; auto.
        apply T_ctn_sequential_exec with T1 T2 ; auto.

(*sequence *)       
- inversion  H_typing; subst; auto.
  + inversion H6; subst;auto.
    inversion H8; subst; auto.
    ++ apply T_config_nil; auto.
       destruct fs. inversion H12; subst; auto.       
       apply T_ctn_sequential_exec with T T'; auto.
       split; auto;intros.
       inversion H.
       inversion H; subst; auto.
       admit. (*surface_syntax*)
       +++ apply T_fs_one; auto.
           admit.
       +++
         apply T_ctn_sequential_exec with T T0; auto.
         admit.
         case_eq (hole_free t); intro. 
         apply T_fs_no_hole with T0; auto. admit.
         apply T_fs_hole ; auto. admit.
         
    ++ apply T_config_nil.
       inversion H10; subst; auto. 
       apply T_ctn_sequential_exec with T T0; auto.
       admit.
       destruct fs.
       +++ destruct H8. intuition.
           subst; auto. inversion H12; subst; auto. 
           apply T_fs_one; auto.
           admit.
       +++ apply  T_fs_no_hole with T1; auto.
           destruct H8. apply H0 with fs; auto.
           admit.
  + inversion H5; subst;auto.
    inversion H10; subst; auto.
    ++ apply T_config_ctns with T' Gamma'; auto.
       destruct fs. inversion H14; subst; auto.       
       apply T_ctn_sequential_exec with T T'; auto.
       split; auto;intros.
       inversion H.
       inversion H; subst; auto.
       admit. (*surface_syntax*)
       +++ apply T_fs_one; auto.
           admit.
       +++
         apply T_ctn_sequential_exec with T T0; auto.
         admit.
         case_eq (hole_free t); intro. 
         apply T_fs_no_hole with T0; auto. admit.
         apply T_fs_hole ; auto. admit.
         
    ++ apply T_config_nil.
       inversion H10; subst; auto. 
       apply T_ctn_sequential_exec with T T0; auto.
       admit.
       destruct fs.
       +++ destruct H8. intuition.
           subst; auto. inversion H12; subst; auto. 
           apply T_fs_one; auto.
           admit.
       +++ apply  T_fs_no_hole with T1; auto.
           destruct H8. apply H0 with fs; auto.
           admit.


           
      

        
        
         
- (*(Container t' fs' lb' sf')*)
  inversion H_typing; subst;auto.
  inversion H7. subst. 
+ inversion H10.
 ++  subst. inversion H9. subst. inversion H5.
+ subst.  apply T_config_nil.
        apply T_ctn_sequential_exec with T0 top fs'0 T1; auto.
    inversion H12. auto. 
+ subst.  apply T_config_ctns with T0 Gamma'; auto. 
    inversion H5. ++
    auto. subst.  
    apply  T_ctn_fs with T1; auto. inversion H11. auto.
    ++ subst.   
        apply T_ctn_sequential_exec with T1 top fs'0 T2; auto.
    inversion H13. auto. 
+ subst. 
    remember ( (update_typing empty_context arg_id (classTy arguT))) as gamma0.
        apply T_config_ctns with  ((OpaqueLabeledTy (classTy returnT))) gamma0; auto.
        apply  T_ctn_fs with (classTy returnT); auto. inversion H14.  auto.  

- (*(Container t' fs' lb' sf')*)
inversion H_typing. subst. inversion H6. subst. 
+ inversion H10.
 ++  subst. inversion H9. subst. inversion H5.
+ subst.  apply T_config_nil.
        apply T_ctn_sequential_exec with T0 top fs'0 T1; auto.
    inversion H12. auto. 
+ subst.  apply T_config_ctns with T0 Gamma'; auto. 
    inversion H5. ++
    auto. subst.  
    apply  T_ctn_fs with T1; auto. inversion H11. auto.
    ++ subst.   
        apply T_ctn_sequential_exec with T1 top fs'0 T2; auto.
    inversion H13. auto. 
+ subst. 
    remember ( (update_typing empty_context arg_id (classTy arguT))) as gamma0.
        apply T_config_ctns with  ((OpaqueLabeledTy (classTy returnT))) gamma0; auto.
        apply  T_ctn_fs with (classTy returnT); auto. inversion H14.  auto.  



(*skip *)
-  inversion  H_typing. subst.
  + inversion H5. subst. 
  ++  apply T_config_nil.  inversion H10; subst; try (inversion H9; fail). 
  +++ apply T_ctn_fs with T';auto.  
  +++ apply T_ctn_fs with T0;auto. 
  +++ apply T_ctn_sequential_exec with  T0 p (fs) T1; auto.
  +++  inversion H9. subst. intuition. 
  +++ subst. inversion H11. 
  ++ subst. inversion H10. subst. 
    inversion H12; subst; try (inversion H8; fail). 
   +++ apply T_config_nil. apply T_ctn_fs with T'; auto. 
  +++ apply T_config_nil.  apply T_ctn_fs with T1;auto. 
  +++ apply T_config_nil.  apply T_ctn_sequential_exec with  T1 p (fs) T2; auto.
  +++ inversion H8. case_eq (hole_free e); intro; rewrite H in H0; inversion H0.
  +++ inversion H8.  case_eq (hole_free x); intro; rewrite H in H0; inversion H0.
 + subst. inversion H4. subst. 
  ++  apply T_config_ctns with (OpaqueLabeledTy T') Gamma'; auto. 
       inversion H11; subst; try (inversion H10; fail). 
  +++  apply T_ctn_fs with T';auto. 
  +++  apply T_ctn_fs with T1;auto. 
  +++ apply T_ctn_sequential_exec with  T1 p (fs) T2; auto.
  +++  inversion H10. subst. intuition. 
  +++ subst. inversion H10. subst. intuition.
  ++ subst. inversion H11. subst. 
    inversion H13; subst; try (inversion H9; fail). 
   +++ apply T_config_ctns with (OpaqueLabeledTy T') Gamma'; auto.  apply T_ctn_fs with T'; auto. 
  +++ apply T_config_ctns with (OpaqueLabeledTy T') Gamma'; auto.  apply T_ctn_fs with T2; auto. 
  +++ apply T_config_ctns with (OpaqueLabeledTy T') Gamma'; auto.  
        apply T_ctn_sequential_exec with  T2 p (fs) T3; auto.
   +++ remember ((update_typing empty_context arg_id (classTy arguT))) as gamma0.
 apply T_config_ctns with  ((OpaqueLabeledTy  T')) Gamma'; auto.
  apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT)); auto.
  apply T_MethodCall with gamma0 T0 cls_def body arg_id arguT; auto.
  +++ inversion H9.  case_eq (hole_free x); intro; rewrite H in H0; inversion H0.

- (*Container t' fs' lb' sf'*)
  inversion  H_typing. subst.
  + inversion H7. subst. 
  ++ apply T_config_nil. 
  inversion H12; subst;  try (inversion H0; fail).
  +++ apply T_ctn_fs with T';auto. 
  +++ apply T_ctn_fs with T0;auto.
  +++  apply T_ctn_sequential_exec with  T0 p ( fs) T1; auto. 
  +++ remember ((update_typing empty_context arg_id (classTy arguT))) as gamma0.
  apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT)); auto.
  apply T_MethodCall with gamma0 T cls_def body arg_id arguT; auto.
  +++   apply T_ctn_fs with ( voidTy); auto. 
  ++ subst. inversion H12. subst. 
    inversion H14; subst; try (inversion H10; fail). 
   +++ apply T_config_nil. apply T_ctn_fs with T'; auto. 
  +++ apply T_config_nil. apply T_ctn_fs with T1; auto. 
  +++ apply T_config_nil. apply T_ctn_sequential_exec with  T1 p ( fs) T2; auto. 
  +++ remember ((update_typing empty_context arg_id (classTy arguT))) as gamma0.
  apply T_config_nil.  apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT)); auto.
  apply T_MethodCall with gamma0 T cls_def body arg_id arguT; auto.
  +++ inversion H10.  case_eq (hole_free x); intro; rewrite H1 in H2; inversion H2.
 + subst. inversion H6. subst. 
  ++  apply T_config_ctns with (OpaqueLabeledTy T') Gamma'; auto.  inversion H13; subst; try (inversion H0; fail). 
  +++  apply T_ctn_fs with T';auto.
  +++  apply T_ctn_fs with T1;auto.
  +++  apply T_ctn_sequential_exec with  T1 p fs T2; auto. 
  +++ remember ((update_typing empty_context arg_id (classTy arguT))) as gamma0.
  apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT)); auto.
  apply T_MethodCall with gamma0 T0 cls_def body arg_id arguT; auto.
  +++ inversion H0. case_eq (hole_free x); intro; rewrite H1 in H2; inversion H2.
  ++ subst. inversion H13. subst. 
    inversion H15; subst; try (inversion H11; fail); 
    apply T_config_ctns with (OpaqueLabeledTy T') Gamma'; auto.  
   +++ apply T_ctn_fs with T'; auto. 
  +++ apply T_ctn_fs with T2; auto. 
  +++ apply T_ctn_sequential_exec with  T2 p fs T3; auto.
  +++ inversion H0.  case_eq (hole_free e); intro; rewrite H1 in H2; inversion H2.
  +++ inversion H0.  case_eq (hole_free x); intro; rewrite H1 in H2; inversion H2.
*)
- admit. - admit. - admit. - admit. - admit. - admit. - admit. - admit. 
- admit. - admit. - admit. - admit. - admit. - admit. - admit. - admit. 
- admit. - admit. - admit. - admit. - admit. - admit. - admit. - admit. 
- admit. - admit. - admit. - admit. - admit. 
(*v_opa_l t lb0*)
- inversion H_typing. subst.
  + inversion H10. subst. 
  ++ inversion H12. subst.  inversion H11. subst.
    inversion H13. subst. 
 inversion H16. subst. 
  +++ apply T_config_nil. case_eq (hole_free top); intro. 
  ++++  apply T_ctn_sequential_exec with (OpaqueLabeledTy T') top fs (OpaqueLabeledTy T2); auto. 
     apply T_v_opa_l; auto. apply value_typing_invariant_gamma with Gamma';auto. 
  ++++ apply H14 in H0. subst.  apply T_ctn_fs with (OpaqueLabeledTy T'); auto. 
    apply T_v_opa_l; auto. apply value_typing_invariant_gamma with Gamma';auto. 
  +++ subst.   apply T_config_ctns with (OpaqueLabeledTy T1) empty_context; auto.  
    case_eq (hole_free top); intro. 
++++  apply T_ctn_sequential_exec with (OpaqueLabeledTy T') top fs (OpaqueLabeledTy T2); auto. 
     apply T_v_opa_l; auto. apply value_typing_invariant_gamma with Gamma';auto. 
  ++++ apply H14 in H0. subst.  apply T_ctn_fs with (OpaqueLabeledTy T'); auto. 
    apply T_v_opa_l; auto. apply value_typing_invariant_gamma with Gamma';auto.

++ subst. inversion H12. 
+ subst. inversion H19. subst. inversion H18. subst. inversion H13. subst.  
    inversion H21. subst. 
    ++ apply T_config_nil.    inversion H17. 
    +++ subst.      remember ( (update_typing empty_context arg_id (classTy arguT))) as gamma0.
    case_eq (hole_free top); intro. 
    ++++  apply T_ctn_sequential_exec with (OpaqueLabeledTy T) top fs (OpaqueLabeledTy T3); auto. 
     apply T_v_opa_l; auto.     apply value_typing_invariant_gamma with gamma0;auto. 

  ++++ apply H15 in H0. subst.  apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT)); auto. 
    apply T_v_opa_l; auto. 
      remember ( (update_typing empty_context arg_id (classTy arguT))) as gamma0.
    apply value_typing_invariant_gamma with gamma0;auto.

 +++ subst. inversion H24. 
++ subst.    apply T_config_ctns with (OpaqueLabeledTy T2) empty_context; auto.      inversion H17. 
    +++ subst.      remember ( (update_typing empty_context arg_id (classTy arguT))) as gamma0.
    case_eq (hole_free top); intro. 
    ++++  apply T_ctn_sequential_exec with (OpaqueLabeledTy T1) top fs (OpaqueLabeledTy T3); auto. 
     apply T_v_opa_l; auto.     apply value_typing_invariant_gamma with gamma0;auto. 

  ++++ apply H15 in H0. subst.  apply T_ctn_fs with (OpaqueLabeledTy (classTy returnT)); auto. 
    apply T_v_opa_l; auto. 
      remember ( (update_typing empty_context arg_id (classTy arguT))) as gamma0.
    apply value_typing_invariant_gamma with gamma0;auto.

 +++ subst. inversion H28.
Admitted. 




  
Hint Resolve typing_preservation.

