Require Import Coq.Arith.Arith.
Require Import Coq.Bool.Bool.
Require Import Coq.Strings.String.
Require Import Coq.Arith.EqNat.
Require Import Coq.omega.Omega.
Require Import Coq.Lists.List.

Add LoadPath "/Users/llama_jian/Develop/HarvardPLCIFC".

Require Import Label. 

(* identifiers *)
Inductive id : Type :=
  | Id : string -> id.

(* class name *)
Inductive cn : Type :=
  | class_name : string -> cn.

Inductive field : Type :=
  | fd : cn -> id -> field.

(* comparison of identifiers *)
Definition beq_id x y :=
  match x,y with
    | Id n1, Id n2 => if string_dec n1 n2 then true else false
  end.

Inductive oid : Type := 
  | OID : nat -> oid.

Inductive tm : Type :=
  | Tvar : id -> tm
  | null : tm
  | FieldAccess : tm -> id -> tm
  | MethodCall : tm -> id -> tm -> tm
  | NewExp : cn -> tm
(* label related *)
  | l : Label -> tm
  | labelData : tm -> Label -> tm
  | unlabel : tm -> tm
  | labelOf : tm -> tm
  | unlabelOpaque : tm -> tm
  | opaqueCall : tm -> tm

(* statements *)
  | Skip : tm
  | Assignment : id -> tm -> tm
  | FieldWrite : tm -> id -> tm -> tm
  | If : id -> id -> tm -> tm -> tm 
  | Sequence : tm -> tm -> tm
  | Return : tm -> tm

(* special terms *)
  | ObjId: oid -> tm
  (* runtime labeled date*)
  | v_l : tm -> Label -> tm
  | v_opa_l : tm -> Label -> tm
  | dot : tm.

Inductive method_def : Type :=
  | m_def : cn -> id -> cn -> id -> tm -> method_def.


Inductive CLASS : Type :=
  | class_def : cn -> (list field) -> (list method_def) -> CLASS. 

Inductive value : tm -> Prop :=
  (* contants are values or normal form *)
  | v_oid :
      forall o, value (ObjId o)
(* skip is not a terminal *)
  | v_none : 
      value Skip
  | v_null :
      value null
  | v_label :
      forall lb, value (l lb)
  | v_labeled : forall v lb,
      value v ->
      value (v_l v lb)
  | v_opa_labeled : forall v lb,
      value v->
      value (v_opa_l v lb)
  | v_dot : 
      value dot.  

(* stack frame *)
Definition stack_frame : Type := id -> (option tm).

Inductive labeled_stack_frame : Type := 
  | Labeled_frame : Label -> stack_frame -> labeled_stack_frame.

Definition get_stack_label (lsf : labeled_stack_frame) : Label :=
  match lsf with 
    | Labeled_frame lb sf => lb
  end. 

Definition sf_update (sf : stack_frame) (x : id) (v : tm) :=
  fun x' => if beq_id x x' then (Some v) else sf x'.


Definition labeled_frame_update (lsf : labeled_stack_frame) (x : id) (v : tm) :=
  match lsf with
    |  Labeled_frame lb sf  =>  Labeled_frame lb (fun x' => if beq_id x x' then (Some v) else sf x')
  end.

Check sf_update.



(* unrestricted access L *)
Definition L_Label := LB nil.

Definition empty_stack_frame : stack_frame := fun _ => None.
Definition empty_labeled_stack_frame : labeled_stack_frame := (Labeled_frame L_Label empty_stack_frame).
Definition main_labeled_stack_frame : labeled_stack_frame := (Labeled_frame L_Label empty_stack_frame).

(* stack *)
Definition stack :Type := list labeled_stack_frame.

Fixpoint update_stack_top (s : stack) (x : id) (v : tm) := 
match s with 
  | cons lsf s' => cons (labeled_frame_update lsf x v) s'
  | nil => nil
end.

Definition get_current_label (s : stack) : Label :=
match s with
  | lsf :: t => (get_stack_label lsf)
  | nil => L_Label
end.

(* Definitions for Heap related*)
Definition FieldMap : Type := id -> (option tm).

Definition fields_update (F : FieldMap) (x : id) (v : tm) :=
  fun x' => if beq_id x x' then (Some v) else F x'.

Inductive heapObj : Type :=
  | Heap_OBJ : CLASS -> FieldMap -> Label -> heapObj.

(*Definition heap := oid -> (option heapObj).*)

Inductive Heap_entry : Type := 
  | heap_entry : oid -> heapObj -> Heap_entry. 
  
Notation "( oid , obj )" := (heap_entry oid obj).

Definition heap := list Heap_entry.

(* comparison of identifiers *)
Definition beq_oid x y :=
  match x,y with
    | OID n1, OID n2 => if beq_nat n1 n2 then true else false
  end.

Fixpoint update_heap_obj (h : heap) (o : oid) (ho : heapObj) :=
   match h with 
      | nil => nil
      | head :: t => match head with 
                            | ( o0 , heap_obj ) => if beq_oid o o0 then cons (o , ho) t
                                                                  else head :: update_heap_obj t o ho
                      end
   end. 

Fixpoint lookup_heap_obj (h : heap) (o : oid) : option heapObj :=
   match h with 
      | nil => None
      | h :: t => match h with 
                            | ( o0 , ho ) => if beq_oid o o0 then Some ho
                                                                  else lookup_heap_obj t o
                      end
   end. 

Definition get_fresh_oid (h:heap) :=
    match h with 
     | nil => (OID 1)
     | h0 :: t0 => match h0 with 
                        | ((OID n) , _) => (OID (n+1)) 
                          end
    end.


Definition add_heap_obj (h: heap) (o:oid) (ho : heapObj) :=
  cons (o, ho) h.

Inductive Sigma := 
  | SIGMA : stack -> heap -> Sigma.

Definition get_stack (sgm : Sigma) : stack :=
  match sgm with
   | SIGMA s h => s
  end.

Definition get_heap (sgm : Sigma) : heap :=
  match sgm with
   | SIGMA s h => h
  end.




Reserved Notation "c1 '/' st '==>' c1' '/' st'"
  (at level 40, st at level 39, c1' at level 39).

Definition current_label (sigma : Sigma) : Label :=
  get_current_label (get_stack sigma).

Definition update_current_label (s : stack) (lb : Label) := 
match s with 
  | cons lsf s' => match lsf with
                            | Labeled_frame lb' sf => cons (Labeled_frame lb sf) s'
                          end 
  | nil => nil
end.


(* variable declaration *)
Inductive vd : Type :=
  | var_def : cn -> id -> vd.

Fixpoint find_method_body (methods : list method_def) (m : id) :=
  match methods with
    | nil => None
    | h :: t =>  match h with 
                  | m_def cls m' cls_a arg_id body => if beq_id m m' then Some (m_def cls m' cls_a arg_id  (Return body)) else find_method_body t m
                 end
  end.

Definition find_method (cls : CLASS) (m : id) := 
  match cls with
    | class_def c_name fields methods => find_method_body methods m
  end.

Definition find_fields (cls : CLASS) := 
  match cls with
    | class_def c_name fields methods => fields
  end.

Fixpoint type_of_field (fields : list field) (f : id) : option cn :=
  match fields with
     | nil => None
     | (fd cls h) :: t => if beq_id h f then Some cls else (type_of_field t f)
  end.

Definition empty_field_map : FieldMap := fun _ => None.

Fixpoint init_field_map (fields : list field) (fm : FieldMap) :=
  match fields with 
    | nil => fm
    | (fd cls h) :: t =>  (fun x' => if beq_id h x' then Some null else (init_field_map t fm) x')
  end.

Check init_field_map.


Lemma empty_fields : forall fields F cls', 
  F = init_field_map fields empty_field_map ->
  (forall f, type_of_field fields f = Some cls' ->
  F f = Some null).
Proof.
  intro. intro. intro. intro. generalize dependent F.  
  induction fields. 
  - intros.   inversion H0.
  - intro F. intro Hy. 
     induction a. intro f. intro. rewrite Hy.
     case_eq (beq_id i f). intro.
     unfold init_field_map. rewrite H0. auto. 
     intro. unfold init_field_map. rewrite H0. fold init_field_map. 
     apply IHfields with (F:=(init_field_map fields empty_field_map))(f:=f).
     auto.   unfold type_of_field in H. rewrite H0 in H. fold type_of_field in H.
    auto.  
Qed.  


Definition Class_table := cn -> option CLASS.
Inductive config := 
  | Config : Class_table -> tm -> Sigma -> config
  | Error_state : config.
Hint Constructors config.

Reserved Notation "c '==>' c'"
  (at level 40, c' at level 39).





Inductive reduction : config -> config -> Prop :=
(* variabel access *)
  | ST_var : forall id sigma s h lb sf lsf v s' ct,
      sigma = SIGMA s h ->
      s = cons lsf s' ->
      lsf = Labeled_frame lb sf ->
      Some v = sf(id) ->
      Config ct (Tvar id) sigma ==> Config ct v sigma

(* field read *)
  (* context rule *)
  | ST_fieldRead1 : forall sigma sigma' e e' f ct,
      Config ct e sigma ==>  Config ct e' sigma' -> 
      Config ct (FieldAccess e f) sigma ==> Config ct (FieldAccess e' f) sigma'
  (* normal field access *)
  | ST_fieldRead2 : forall sigma sigma' o s h fname lb cls fields v l' s' ct,
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls fields lb) = lookup_heap_obj h o -> 
      Some v = fields(fname) -> 
      l' = join_label lb (current_label sigma) ->
      s' = update_current_label s l'-> 
      sigma' = SIGMA s' h ->
      Config ct (FieldAccess (ObjId o) fname) sigma ==> Config ct v sigma'
  (* null pointer exception for field access *)
  | ST_fieldReadException : forall sigma f ct,
      Config ct (FieldAccess null f) sigma ==> Error_state
  | ST_fieldRead3 : forall sigma e f ct,
      Config ct e sigma ==>  Error_state -> 
      Config ct (FieldAccess e f) sigma ==> Error_state



(* method call *)
  (* context rule: evaluate object target *)
  | ST_MethodCall1 : forall sigma sigma' e e' e2 id ct,
       Config ct e sigma ==>  Config ct e' sigma' -> 
      Config ct (MethodCall e id e2) sigma ==> Config ct (MethodCall e' id e2)  sigma'
  (* context rule: evaluate arguments *)
  | ST_MethodCall2 : forall sigma sigma' v e e' id ct,
      (forall t, value t -> t<> null -> e <> unlabelOpaque t) ->
      Config ct e sigma ==>  Config ct e' sigma' -> 
      value v ->
      Config ct (MethodCall v id e) sigma ==> Config ct (MethodCall v id e') sigma'
  (* normal method call *)
  | ST_MethodCall3 : forall sigma sigma' o s h cls fields v lx l s' sf lsf arg_id cls_a body meth returnT ct,
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls fields lx) = lookup_heap_obj h o -> 
      Some (m_def returnT meth cls_a arg_id (Return body)) = find_method cls meth -> 
      value v ->
      sf = sf_update empty_stack_frame arg_id v ->
      l = (current_label sigma) ->
      lsf = Labeled_frame l sf ->
      s' = cons lsf s ->
      sigma' = SIGMA s' (get_heap sigma) ->
      Config ct (MethodCall (ObjId o) meth v) sigma ==>  Config ct (Return body) sigma'
  (* null pointer exception for method call *)
  | ST_MethodCallException : forall sigma v meth ct, 
      Config ct (MethodCall null meth v) sigma ==> Error_state
  (* context rule error 1*)
  | ST_MethodCall4 : forall sigma e e2 id ct,
       Config ct e sigma ==>  Error_state -> 
      Config ct (MethodCall e id e2) sigma ==> Error_state
  (* context rule error 2*)
  | ST_MethodCall5 : forall sigma v e id ct,
      (forall t, value t -> t<> null -> e <> unlabelOpaque t) ->
      Config ct e sigma ==>  Error_state -> 
      value v ->
      Config ct (MethodCall v id e) sigma ==> Error_state


(* method call with unlabel opaque *)
  | ST_MethodCall_unlableOpaque : forall sigma sigma' o s h cls fields v lx l' lb s' sf lsf arg_id cls_a body meth returnT ct,
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls fields lx) =lookup_heap_obj h o -> 
      sf = sf_update empty_stack_frame arg_id v ->
      l' = join_label lb (current_label sigma) ->
      lsf = Labeled_frame l' sf ->
      s' = cons lsf s ->
      value v ->
      Some (m_def returnT meth cls_a arg_id  (Return body)) = find_method cls meth ->
      sigma' = SIGMA s' (get_heap sigma) ->
      Config ct (MethodCall (ObjId o) meth (unlabelOpaque (v_opa_l v lb)))  sigma ==>Config ct (Return body) sigma'

  (* null pointer exception for method call with unlabel opaque of null data*)
  | ST_MethodCallOpaqueDataException : forall sigma o meth ct, 
      Config ct (MethodCall (ObjId o) meth (unlabelOpaque null)) sigma ==> Error_state

(* new expression *)
  | ST_NewExp : forall sigma sigma' h h' s o lb cls_name field_defs method_defs cls F ct,
      ct cls_name = Some cls ->
      sigma = SIGMA s h->
      lb = (current_label sigma) -> 
      o = get_fresh_oid h ->
      cls = (class_def cls_name field_defs method_defs) ->
      F =  (init_field_map (find_fields cls) empty_field_map) ->
      h' = add_heap_obj h o (Heap_OBJ cls F lb) ->
      sigma' = SIGMA s h' ->
      Config ct (NewExp cls_name) sigma ==> Config ct (ObjId o) sigma'


(* label data express *)
  (* context rule *)
  | ST_LabelData1 : forall sigma sigma' e e' lb ct,
      Config ct e sigma ==>  Config ct e' sigma' -> 
      Config ct (labelData e lb) sigma ==> Config ct (labelData e' lb) sigma'
  (* label data *)
  | ST_LabelData2 : forall sigma v lb ct,
      value v ->
      Config ct (labelData v lb) sigma ==>  Config ct (v_l v lb)  sigma
  (* label data exception *)
  | ST_LabelDataException : forall sigma lb ct,
      Config ct (labelData null lb) sigma ==> Error_state
  (* context rule error*)
  | ST_LabelDataError : forall sigma e lb ct,
      Config ct e sigma ==>  Error_state -> 
      Config ct (labelData e lb) sigma ==> Error_state




(* unlabel *)
  (* context rule *)
  | ST_unlabel1 : forall sigma sigma' e e' ct,
      Config ct e sigma ==>  Config ct e' sigma' -> 
      Config ct  (unlabel e) sigma ==> Config ct (unlabel e') sigma'
  (* unlabel *)
  | ST_unlabel2 : forall sigma v lb l' sigma' s h s' ct,
      sigma = SIGMA s h ->
      l' = join_label lb (current_label sigma) ->
      s' = update_current_label s l'-> 
      sigma' = SIGMA s' (get_heap sigma) ->
      value v ->
      Config ct (unlabel (v_l v lb)) sigma ==> Config ct v sigma'
  (* unlabel data exception *)
  | ST_unlabelDataException : forall sigma ct,
      Config ct (unlabel null) sigma ==> Error_state
  (* context rule error*)
  | ST_unlabelContextError : forall sigma  e ct,
      Config ct e sigma ==>  Error_state -> 
      Config ct  (unlabel e) sigma ==> Error_state


(* Label of *)
  (* context rule *)
  | ST_labelof1 : forall sigma sigma' e e' ct,
       Config ct e sigma ==>  Config ct e' sigma' -> 
       Config ct (labelOf e) sigma ==> Config ct (labelOf e') sigma'
  (* label of  *)
  | ST_labelof2 : forall sigma v lb ct,
      Config ct (labelOf (v_l v lb)) sigma ==> Config ct (l lb) sigma
  | ST_labelOfDataException : forall sigma ct, 
      Config ct (labelOf null) sigma ==> Error_state
  (* context rule error*)
  | ST_labelofCtxError : forall sigma e ct,
       Config ct e sigma ==>  Error_state -> 
       Config ct (labelOf e) sigma ==> Error_state

(* unlabel opaque*)
  (* context rule *)
  | ST_unlabel_opaque1 : forall sigma sigma' e e' ct,
      Config ct e sigma ==>  Config ct e' sigma' -> 
     Config ct (unlabelOpaque e) sigma ==>  Config ct (unlabelOpaque e') sigma'
  (* context rule error*)
  | ST_unlabel_opaque_ctx_error : forall sigma e ct,
      Config ct e sigma ==>  Error_state -> 
     Config ct (unlabelOpaque e) sigma ==>  Error_state
  (* unlabel opaque *)
  | ST_unlabel_opaque2 : forall sigma v lb l' sigma' s h s'  ct,
      sigma = SIGMA s h ->
      l' = join_label lb (current_label sigma) ->
      s' = update_current_label s l'-> 
      sigma' = SIGMA s' (get_heap sigma) ->
      Config ct (unlabelOpaque (v_opa_l v lb)) sigma ==> Config ct v sigma'
  | ST_unlabel_opaqueDataException : forall sigma ct, 
      Config ct (unlabelOpaque null) sigma ==> Error_state

(* Opaque call *)
  (* context rule *)
  | ST_opaquecall1 : forall sigma sigma' e e' ct,
       (forall v, value v -> e <> Return v) ->
       Config ct e sigma ==>  Config ct e' sigma' -> 
      Config ct (opaqueCall e) sigma ==> Config ct (opaqueCall e') sigma'
  (* context rule error*)
  | ST_opaquecall_ctx_error : forall sigma e ct,
      Config ct e sigma ==>  Error_state -> 
     Config ct (opaqueCall e) sigma  ==>  Error_state
  (* return context rule*)
  | ST_opaquecall_return1 : forall sigma sigma' e e' ct,
       Config ct e sigma ==> Config ct e' sigma' -> 
      Config ct (opaqueCall (Return e)) sigma ==> Config ct (opaqueCall (Return e')) sigma'
  (* return context rule error*)
  | ST_opaquecall_return_error : forall sigma e ct,
       Config ct e sigma ==> Error_state -> 
      Config ct (opaqueCall (Return e)) sigma ==> Error_state


  (* opaque call with value, without method call inside *)
  | ST_opaquecall_val2 : forall sigma v lb ct,
      (value v) ->
      lb = (current_label sigma) ->
      Config ct (opaqueCall v) sigma ==>  Config ct (v_opa_l v lb) sigma  
  (* opaque call with return statement *)
  | ST_opaquecall_return2 : forall sigma sigma' s h lb s' lsf v ct,
      sigma = SIGMA s h->
      s = cons lsf s' ->
      s' <> nil ->
      lb = (current_label sigma) ->
      sigma' = SIGMA s' h->
      value v ->
      Config ct (opaqueCall (Return v)) sigma ==> Config ct  (v_opa_l v lb) sigma'
  | ST_opaquecall_return3 : forall sigma ct,
      Config ct (opaqueCall (Return null)) sigma ==> Error_state
  | ST_opaquecall_return4 : forall sigma v s h lsf ct, 
      value v ->
      sigma = SIGMA s h ->
      s = cons lsf nil ->
      Config ct (opaqueCall (Return v)) sigma ==> Error_state


(* assignment *)
  (* context rule *)
  | ST_assignment1 : forall sigma sigma' e e' id ct,
       Config ct e sigma ==> Config ct e' sigma' -> 
       Config ct (Assignment id e) sigma ==> Config ct (Assignment id e') sigma'
  (* context rule error*)
  | ST_assignment_ctx_error : forall sigma e id ct,
      Config ct e sigma ==>  Error_state -> 
     Config ct  (Assignment id e) sigma  ==>  Error_state
  (* assignment *)
  | ST_assignment2 : forall sigma sigma' id v s' s h ct,
       value v ->
       sigma = SIGMA s h ->
       s' = update_stack_top s id v->
       sigma' = SIGMA s' h ->
       Config ct (Assignment id v) sigma ==> Config ct Skip sigma'

(* Field Write *)
  (* context rule 1 *)
  | ST_fieldWrite1 : forall sigma sigma' f e1 e1' e2 ct,
       Config ct e1 sigma ==> Config ct e1' sigma' -> 
       Config ct (FieldWrite e1 f e2) sigma ==> Config ct (FieldWrite e1' f e2) sigma'
  (* context rule error 1 *)
  | ST_fieldWrite_ctx_error1 : forall sigma f e1 e2 ct,
       Config ct e1 sigma ==> Error_state -> 
       Config ct (FieldWrite e1 f e2) sigma ==> Error_state
  (* context rule 2 *)
  | ST_fieldWrite2 : forall sigma sigma' f v e2 e2' ct,
       (forall t, value t -> t<> null -> e2 <> unlabelOpaque t) ->
       value v ->
       Config ct e2 sigma ==> Config ct e2' sigma' -> 
       Config ct (FieldWrite v f e2) sigma ==> Config ct (FieldWrite v f e2') sigma'
  (* context rule error 2 *)
  | ST_fieldWrite_ctx_error2 : forall sigma f v e2 ct,
       (forall t, value t -> t<> null -> e2 <> unlabelOpaque t) ->
       value v ->
       Config ct e2 sigma ==> Error_state -> 
       Config ct (FieldWrite v f e2) sigma ==> Error_state
  (* field write normal *)
  | ST_fieldWrite3 : forall sigma sigma' o s h h' f lb cls F F' v l' ct,
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls F lb) = lookup_heap_obj h o -> 
      F' = fields_update F f v ->
      l' = join_label lb (current_label sigma) ->
      h' = update_heap_obj h o (Heap_OBJ cls F' l') ->
      sigma' = SIGMA s h' ->
      value v->
      Config ct (FieldWrite (ObjId o) f v) sigma ==> Config ct Skip sigma'
  (* null pointer exception for field write *)
  | ST_fieldWriteException : forall sigma f v ct, 
      Config ct (FieldWrite null f v) sigma ==> Error_state
  (* field write normal *)
  | ST_fieldWrite_opaque : forall sigma sigma' o s h h' f lo cls F F' v l' lb e2 ct,
      e2 = unlabelOpaque (v_opa_l v lb) ->
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls F lo) = lookup_heap_obj h o-> 
      F' = fields_update F f v ->
      l' = join_label lo lb ->
      h' = update_heap_obj h o (Heap_OBJ cls F' l') ->
      sigma' = SIGMA s h' ->
      value v ->
      Config ct (FieldWrite (ObjId o) f e2) sigma ==> Config ct Skip sigma'
  | ST_FieldWriteOpaqueDataException : forall sigma o f ct, 
      Config ct (FieldWrite (ObjId o) f (unlabelOpaque null)) sigma ==> Error_state

(* return statement *)
  (* context rule*)
  | ST_return1 : forall sigma sigma' e e' ct,
        Config ct e sigma ==> Config ct e' sigma' -> 
        Config ct (Return e) sigma ==> Config ct (Return e') sigma'
  (* context rule error*)
  | ST_return_ctx_error : forall sigma e ct,
        Config ct e sigma ==> Error_state -> 
        Config ct (Return e) sigma ==> Error_state
  (* return val *)
  | ST_return2 : forall sigma sigma' v s s' s'' h lsf l' ct, 
      value v ->
      sigma = SIGMA s h ->
      s = cons lsf s' ->
      s' <> nil ->
      l' = join_label (get_current_label s) (get_current_label s') ->
      s'' = update_current_label s' l' ->
      sigma' = SIGMA s'' h ->
      Config ct (Return v) sigma ==> Config ct v sigma'
  | ST_return_terminal : forall sigma v s h lsf ct, 
      value v ->
      sigma = SIGMA s h ->
      s = cons lsf nil ->
      Config ct (Return v) sigma ==> Error_state

(* if statement *)
  | ST_if_b1 : forall sigma s1 s2 s h lsf s' lb sf id1 id2 ct, 
       sigma = SIGMA s h ->
       s = cons lsf s' ->
       lsf = Labeled_frame lb sf ->
       sf(id1) = sf(id2) ->
       Config ct (If id1 id2 s1 s2) sigma ==> Config ct s1 sigma
  | ST_if_b2 : forall sigma s1 s2 s h lsf s' lb sf id1 id2 ct, 
       sigma = SIGMA s h ->
       s = cons lsf s' ->
       lsf = Labeled_frame lb sf ->
       sf(id1) <> sf(id2) ->
       Config ct (If id1 id2 s1 s2) sigma ==> Config ct s2 sigma
(* sequence *)
   (* context rule *)
  | ST_seq1 : forall sigma s1 s2 s1' sigma' ct, 
    Config ct s1 sigma ==> Config ct s1' sigma' -> 
    Config ct (Sequence s1 s2) sigma ==> Config ct (Sequence s1' s2) sigma'
  (* context rule error *)   
  | ST_seq_ctx_error : forall sigma s1 s2 ct, 
    Config ct s1 sigma ==> Error_state -> 
    Config ct (Sequence s1 s2) sigma ==> Error_state
   (* sequence rule *)
  | ST_seq2 : forall sigma v s ct, 
    value v->
    Config ct (Sequence v s) sigma ==> Config ct s sigma

where "c '==>' c'" := (reduction c c').




Inductive ty : Type :=
  | classTy : cn -> ty 
  | LabelTy : ty
  | LabelelTy : ty -> ty
  | OpaqueLabeledTy : ty -> ty
  | voidTy : ty. 

Definition typing_context := id -> (option ty).
Definition empty_context : typing_context := fun _ => None.

Definition update_typing (gamma : typing_context) (x:id) (T : ty) : typing_context :=
      fun x' => if beq_id x x' then (Some T) else gamma x. 



Inductive has_type : Class_table -> typing_context -> heap -> tm -> ty -> Prop :=
(*variable *)
  | T_Var : forall Gamma x T CT h , 
      Gamma x = Some (classTy T) ->
      has_type CT Gamma h (Tvar x) (classTy T)
(* null *)
  | T_null : forall Gamma h T CT, 
      has_type CT Gamma h null T
(* Field read *)
  | T_FieldAccess : forall Gamma e f cls_def CT clsT cls' h fields_def,
      has_type CT Gamma h e (classTy clsT) ->
      Some cls_def = CT(clsT) ->
      fields_def = (find_fields cls_def) ->
      type_of_field fields_def f = Some cls' ->
      has_type CT Gamma h (FieldAccess e f) (classTy cls')
(* method call *)
  | T_MethodCall : forall Gamma Gamma' e meth argu CT h T returnT cls_def body arg_id arguT,
      has_type CT Gamma h e (classTy T) ->
      has_type CT Gamma h argu (classTy arguT) ->
      Some cls_def = CT(T) ->
      find_method cls_def meth = Some (m_def returnT meth arguT arg_id (Return body))  ->
      Gamma' = update_typing empty_context arg_id (classTy arguT) ->
      has_type CT Gamma' h (body) (classTy returnT) ->
      has_type CT Gamma h (Return body) (classTy returnT) ->
      has_type CT Gamma h (MethodCall e meth argu) (classTy returnT)
(* new exp *)
  | T_NewExp : forall h Gamma cls_name CT, 
      (exists cls_def field_defs method_defs, CT cls_name = Some cls_def /\
              cls_def = class_def cls_name field_defs method_defs) ->
      has_type CT Gamma h (NewExp cls_name) (classTy cls_name)
(* label *)
  | T_label : forall h Gamma lb CT,
      has_type CT Gamma h (l lb) LabelTy
(* label data *)
  | T_labelData : forall h Gamma lb CT e T,
      has_type CT Gamma h (l lb) LabelTy ->
      has_type CT Gamma h e T ->
      has_type CT Gamma h (labelData e lb) (LabelelTy T)
(* unlabel *)
  | T_unlabel : forall h Gamma CT e T,
      has_type CT Gamma h e (LabelelTy T) ->
      has_type CT Gamma h (unlabel e) T
(* labelOf *)
  | T_labelOf : forall h Gamma CT e T,
      has_type CT Gamma h e (LabelelTy T) ->
      has_type CT Gamma h (labelOf e) LabelTy
(* unlabel opaque *)
  | T_unlabelOpaque : forall h Gamma CT e T,
      has_type CT Gamma h e (OpaqueLabeledTy T) -> 
      has_type CT Gamma h (unlabelOpaque e) T
(* opaque call 1 *)
  | T_opaqueCall : forall h Gamma CT e T,
      has_type CT Gamma h e T ->
      has_type CT Gamma h (opaqueCall e) (OpaqueLabeledTy T)
(* Skip *)
  | T_skip : forall h Gamma CT,
      has_type CT Gamma h Skip voidTy
(* assignment *)
  | T_assignment : forall h Gamma CT e T x, 
      Gamma x = Some T ->
      has_type CT Gamma h e T ->
      has_type CT Gamma h (Assignment x e) voidTy
(* Field Write *)
  | T_FieldWrite : forall h Gamma x f cls_def CT clsT cls' e,
      has_type CT Gamma h x (classTy clsT) ->
      has_type CT Gamma h e (classTy cls') ->
      Some cls_def = CT(clsT) ->
      type_of_field (find_fields cls_def) f = Some cls' ->
      has_type CT Gamma h (FieldWrite x f e) voidTy
(* if *)
  | T_if : forall Gamma h CT id1 id2 s1 s2 T T' ,
      has_type CT Gamma h (Tvar id1) (classTy T) ->
      has_type CT Gamma h (Tvar id2) (classTy T) ->
      has_type CT Gamma h s1 T' ->
      has_type CT Gamma h s2 T' ->
      has_type CT Gamma h (If id1 id2 s1 s2) T'
(* sequence *)
  | T_sequence : forall h Gamma CT e1 e2 T T',
      has_type CT Gamma h e1 T ->
      has_type CT Gamma h e2 T' ->
      has_type CT Gamma h (Sequence e1 e2) T'
(* return *)
  | T_return : forall h Gamma CT e T,
      has_type CT Gamma h e T ->
      T <> voidTy ->
      has_type CT Gamma h (Return e) T
(* ObjId *)
  | T_ObjId : forall h Gamma CT o cls_name cls_def,
      Some cls_def = CT(cls_name) ->
      (exists field_defs method_defs, cls_def = (class_def cls_name field_defs method_defs)) ->
      (exists F lo, lookup_heap_obj h o = Some (Heap_OBJ cls_def F lo)) ->
      has_type CT Gamma h (ObjId o) (classTy cls_name)
(* runtime labeled data *)
  | T_v_l : forall h Gamma lb CT v T,
      has_type CT Gamma h (l lb)  LabelTy ->
      has_type CT Gamma h v  T ->
      value v ->
      has_type CT Gamma h (v_l v lb) (LabelelTy T)
(* runtime labeled data *)
  | T_v_opa_l : forall h Gamma lb CT v T,
      has_type CT Gamma h (l lb)  LabelTy ->
      has_type CT Gamma h v  T ->
      value v ->
      has_type CT Gamma h (v_opa_l v lb) (OpaqueLabeledTy T)
  | T_dot : forall h Gamma T CT,
      has_type CT Gamma h dot T. 




Inductive wfe_stack_frame : Class_table -> heap -> labeled_stack_frame -> Prop :=
  | stack_frame_wfe : forall h lsf sf lb ct,
        lsf = Labeled_frame lb sf ->
         (forall x v, sf x = Some v  ->
               (
               v = null \/ 
                 ( exists cls_name o, v = ObjId o 
                              /\ (exists F lo field_defs method_defs , lookup_heap_obj h o = Some (Heap_OBJ (class_def cls_name field_defs method_defs) F lo)
                                      /\ (ct cls_name = Some (class_def cls_name field_defs method_defs))
                                   ) 
                  )    )  ) ->
        wfe_stack_frame ct h lsf. 

Definition empty_heap : heap := nil.

Definition compare_oid (o1 : oid) (o2 : oid) :=
  match o1, o2 with 
      | OID n1, OID n2 => if (gt_dec n1  n2) then true else false
  end.

Inductive wfe_heap : Class_table -> heap -> Prop :=
  | empty_heap_wfe : forall ct, 
        wfe_heap ct  empty_heap
  | heap_wfe : forall h h' o cls_def F ct cn ho lo method_defs field_defs ,
        h' = (o , ho) :: h ->
        (h = nil \/ (exists o' ho' h'', h = (o' , ho') :: h'' /\ compare_oid o o' = true) ) ->
        wfe_heap ct h ->
        ho = (Heap_OBJ cls_def F lo) ->
        Some cls_def  = ct cn ->
        cls_def = class_def cn field_defs method_defs ->
        wfe_heap ct h'.

Inductive field_wfe_heap : Class_table -> heap -> Prop :=
  | heap_wfe_fields : forall h ct, 
        (forall o cls_def F cls_name lo method_defs field_defs,
        lookup_heap_obj  h o = Some (Heap_OBJ cls_def F lo) ->
        Some cls_def  = ct cls_name ->
        cls_def = class_def cls_name field_defs method_defs ->
        (forall f cls', type_of_field field_defs f = Some cls' -> 
                exists v, F(f) = Some v
                 /\ (v= null  \/ 
                          ( exists o' F' lx field_defs0 method_defs0, v = ObjId o' 
                                  /\ lookup_heap_obj  h o' = Some (Heap_OBJ (class_def cls' field_defs0 method_defs0) F' lx)
                                    /\ ct cls' = Some (class_def cls' field_defs0 method_defs0)
                          ) ) 
        ))->
        field_wfe_heap ct h.

Inductive wfe_stack : Class_table -> heap -> stack -> Prop :=
  | main_stack_wfe : forall ct s h lb,
        wfe_heap ct h -> 
        s = cons (Labeled_frame lb empty_stack_frame) nil ->
        forall lb, wfe_stack ct h (cons (Labeled_frame lb empty_stack_frame) nil)
  | stack_wfe : forall s ct s' lb sf h, 
        s = cons (Labeled_frame lb sf) s'->
        wfe_stack ct h s' ->
        wfe_heap ct h ->
        wfe_stack_frame ct h (Labeled_frame lb sf) ->
        wfe_stack ct h s.

Lemma wfe_stack_value : forall gamma CT s h sigma v clsT, 
    sigma = SIGMA s h ->  wfe_heap CT h -> wfe_stack CT h s 
      -> (has_type CT gamma h v (classTy clsT))
      -> value v -> (v = dot \/ v = null \/ 
                 ( exists o, v = ObjId o 
                              /\ (exists F lo field_defs method_defs , 
                                      lookup_heap_obj h o = Some (Heap_OBJ (class_def clsT field_defs method_defs) F lo)
                                      /\ (CT clsT = Some (class_def clsT field_defs method_defs))
                                   )
                  )    ).
Proof. 
    intros gamma CT s h sigma v clsT. intro. intro. intro.  intro. intro. 
    induction H3. right. right.  exists o. split. auto. inversion H2. 
    destruct H10 as [F].     destruct H10 as [lo].    
    destruct H9 as [field_defs].    destruct H9 as [method_defs]. 
    exists F. exists lo. exists field_defs. exists method_defs.  
    split. rewrite <-H9. rewrite <- H10. auto. rewrite <- H9. auto.
    
    inversion H2. 

    right. left. auto. 
    right. inversion H2. right.  inversion H2. right.  inversion H2. left. auto.
Qed.   

(* reduction preserve well-form of stack and heap *)
Theorem reduction_preserve_wfe : forall CT s s' h h' sigma sigma',
    sigma = SIGMA s h ->  wfe_heap CT h -> wfe_stack CT h s ->     field_wfe_heap CT h -> 
     sigma' = SIGMA s' h' -> 
    forall t T, has_type CT empty_context h t T -> 
     forall t',  Config CT t sigma ==> Config CT t' sigma' ->
    wfe_heap CT h' /\ wfe_stack CT h' s' /\  field_wfe_heap CT h'.
Proof with auto.

Admitted. 



Reserved Notation "c '=e=>' c'"
  (at level 40, c' at level 39).

Inductive erasure : config -> config -> Prop :=
(* variabel access *)
  | Er_var_L : forall id sigma lb ct,
      lb = (current_label sigma) -> 
      flow_to lb L_Label = true ->
      Config ct (Tvar id) sigma =e=> Config ct (Tvar id) sigma

  | Er_var_H : forall id sigma lb ct,
      lb = (current_label sigma) -> 
      flow_to lb L_Label = false ->
      Config ct (Tvar id) sigma =e=> Config ct dot sigma

(* field read *)
  | Er_fieldRead1 : forall sigma sigma' e e' f ct e'' sigma'',
      Config ct e sigma =e=>  Config ct e' sigma' -> 
      Config ct (FieldAccess e' f) sigma' =e=> Config ct e'' sigma'' ->
      Config ct (FieldAccess e f) sigma =e=> Config ct e'' sigma''

  | Er_fieldRead2 : forall sigma f ct,
      Config ct (FieldAccess dot f) sigma =e=> Config ct dot sigma
      

  | Er_fieldRead3 : forall sigma ct o fname s h cls fields lo lb,
      lb = (current_label sigma) -> 
      flow_to lb L_Label = true ->
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls fields lo) =lookup_heap_obj h o -> 
      flow_to lo L_Label = true ->
      Config ct (FieldAccess (ObjId o) fname) sigma =e=> Config ct dot sigma

  | Er_fieldRead4 : forall sigma ct o fname s h cls fields lo cur_lbl sigma' l' s',
      cur_lbl = (current_label sigma) -> 
      flow_to cur_lbl L_Label = true ->
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls fields lo) =lookup_heap_obj h o -> 
      flow_to lo L_Label = false ->
      l' = join_label cur_lbl lo ->
      s' = update_current_label s l'-> 
      sigma' = SIGMA s' h ->
      Config ct (FieldAccess (ObjId o) fname) sigma =e=> Config ct dot sigma'

(* method call *)
  | Er_MethodCall1 : forall sigma sigma' e e' e2 id ct e'' sigma'',
       Config ct e sigma =e=>  Config ct e' sigma' -> 
       Config ct (MethodCall e' id e2)  sigma' =e=>  Config ct e'' sigma'' -> 
      Config ct (MethodCall e id e2) sigma =e=>  Config ct e'' sigma''

  | Er_MethodCall2 : forall sigma e id ct,
      Config ct (MethodCall dot id e) sigma =e=> Config ct dot sigma

  | Er_MethodCall3 : forall sigma sigma' e e' id ct o cls fields lo s h,
      Config ct e sigma =e=>  Config ct e' sigma' ->
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls fields lo) =lookup_heap_obj h o -> 
      flow_to lo L_Label = true ->
      Config ct (MethodCall (ObjId o)  id e) sigma =e=> Config ct (MethodCall (ObjId o) id e')  sigma'

  | Er_MethodCall4 : forall sigma id ct o,
      Config ct (MethodCall (ObjId o) id dot) sigma =e=> Config ct dot sigma

  | Er_MethodCall5 : forall sigma id ct o v s h cls fields lo lb,
      value v ->
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls fields lo) =lookup_heap_obj h o -> 
      lb = (current_label sigma) -> 
      flow_to lb L_Label = true ->
      Config ct (MethodCall (ObjId o) id v) sigma  =e=> Config ct (MethodCall (ObjId o) id v) sigma

  | Er_MethodCall6 : forall sigma id ct o v cur_lbl,
      value v ->
      cur_lbl = (current_label sigma) -> 
      flow_to cur_lbl L_Label = false ->
      Config ct (MethodCall (ObjId o) id v) sigma  =e=> Config ct dot sigma

  | Er_MethodCall7 : forall sigma id ct o,
      Config ct (MethodCall (ObjId o) id dot) sigma  =e=> Config ct dot sigma

(* method call with unlabel opaque *)
  | Er_MethodCall_unlableOpaque_L : forall sigma o s h cls fields v lx cur_lbl lo ct meth,
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls fields lx) =lookup_heap_obj h o -> 
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = true ->
      Config ct (MethodCall (ObjId o) meth (unlabelOpaque (v_opa_l v lo)))  sigma =e=> 
          Config ct (MethodCall (ObjId o) meth (unlabelOpaque (v_opa_l v lo)))  sigma

  | Er_MethodCall_unlableOpaque_H : forall sigma o s h cls fields v lx cur_lbl lo ct meth,
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls fields lx) =lookup_heap_obj h o -> 
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = false ->
      Config ct (MethodCall (ObjId o) meth (unlabelOpaque (v_opa_l v lo)))  sigma =e=>Config ct dot sigma

(* new expression *)
  | Er_NewExp_H : forall sigma ct cur_lbl cls_name,
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = false ->
      Config ct (NewExp cls_name) sigma =e=> Config ct dot sigma

  | Er_NewExp_L : forall sigma ct cls_name cur_lbl,
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = true ->
      Config ct (NewExp cls_name) sigma =e=> Config ct (NewExp cls_name) sigma

(* label data express *)
  (* context rule *)
  | Er_LabelData1 : forall sigma sigma' e e' lb ct e'' sigma'',
      Config ct e sigma =e=>  Config ct e' sigma' -> 
      Config ct (labelData e' lb) sigma' =e=> Config ct e'' sigma'' -> 
      Config ct (labelData e lb) sigma =e=> Config ct e'' sigma''
  | Er_LabelData_dot : forall sigma lb ct,
      Config ct (labelData dot lb) sigma =e=> Config ct dot sigma
  (* label data *)
  | Er_LabelData2 : forall sigma v lb ct cur_lbl,
      value v ->
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = true ->
      Config ct (labelData v lb) sigma =e=>  Config ct (labelData v lb)  sigma
  | Er_LabelData3 : forall sigma v lb ct cur_lbl,
      value v ->
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = false ->
      Config ct (labelData v lb) sigma =e=>  Config ct dot  sigma


(* unlabel *)
  (* context rule *)
  | Er_unlabel1 : forall sigma sigma' e e' ct e'' sigma'',
      Config ct e sigma =e=>  Config ct e' sigma' -> 
      Config ct (unlabel e') sigma' =e=> Config ct e'' sigma'' -> 
      Config ct  (unlabel e) sigma =e=> Config ct e'' sigma''
  | Er_unlabel_dot : forall sigma ct,
      Config ct  (unlabel dot) sigma =e=> Config ct dot sigma
  (* unlabel *)
  | Er_unlabel_H : forall sigma v lb l' sigma' s h s' ct cur_lbl,
      sigma = SIGMA s h ->
      l' = join_label lb (current_label sigma) ->
      s' = update_current_label s l'-> 
      sigma' = SIGMA s' (get_heap sigma) ->
      value v ->
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = false ->
      Config ct (unlabel (v_l v lb)) sigma =e=> Config ct dot sigma'

  | Er_unlabel_L : forall sigma v lb l' sigma' s h s' ct cur_lbl,
      sigma = SIGMA s h ->
      l' = join_label lb (current_label sigma) ->
      s' = update_current_label s l'-> 
      sigma' = SIGMA s' h ->
      value v ->
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = true ->
      Config ct (unlabel (v_l v lb)) sigma =e=> Config ct (unlabel (v_l v lb)) sigma'

(* Label of *)
  (* context rule *)
  | Er_labelof1 : forall sigma sigma' e e' ct,
       Config ct e sigma =e=>  Config ct e' sigma' -> 
       Config ct (labelOf e) sigma =e=> Config ct (labelOf e') sigma'
  | Er_labelof_dot : forall sigma ct,
       Config ct (labelOf dot) sigma =e=> Config ct dot sigma
  (* label of  *)
  | Er_labelof_L : forall sigma v lb ct cur_lbl,
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = true ->
      Config ct (labelOf (v_l v lb)) sigma =e=> Config ct (labelOf (v_l v lb)) sigma

  | Er_labelof_H : forall sigma v lb ct cur_lbl,
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = false ->
      Config ct (labelOf (v_l v lb)) sigma =e=> Config ct dot sigma

(* unlabel opaque*)
  (* context rule *)
  | Er_unlabel_opaque1 : forall sigma sigma' e e' ct e'' sigma'',
      Config ct e sigma =e=>  Config ct e' sigma' -> 
      Config ct (unlabelOpaque e') sigma' =e=>  Config ct e'' sigma'' -> 
     Config ct (unlabelOpaque e) sigma =e=>  Config ct e'' sigma''
  | Er_unlabel_opaque_dot : forall sigma ct,
      Config ct  (unlabelOpaque dot) sigma =e=> Config ct dot sigma
  (* unlabel opaque *)
  | Er_unlabel_opaque_L : forall sigma v lb ct cur_lbl,
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = true ->
      value v ->
      Config ct (unlabelOpaque (v_opa_l v lb)) sigma =e=> Config ct (unlabelOpaque (v_opa_l v lb)) sigma
  | Er_unlabel_opaque_H : forall sigma v lb l' sigma' s h s'  ct cur_lbl,
      sigma = SIGMA s h ->
      l' = join_label lb (current_label sigma) ->
      s' = update_current_label s l'-> 
      sigma' = SIGMA s' h ->
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = false ->
      value v ->
      Config ct (unlabelOpaque (v_opa_l v lb)) sigma =e=> Config ct dot sigma

(* Opaque call *)
  (* context rule *)
  | Er_opaquecall1 : forall sigma sigma' e e' ct e'' sigma'',
       (forall v, value v -> e <> Return v) ->
       Config ct e sigma =e=>  Config ct e' sigma' -> 
      Config ct (opaqueCall e') sigma' =e=>  Config ct e'' sigma'' -> 
      Config ct (opaqueCall e) sigma =e=> Config ct e'' sigma''
  | Er_opaquecall_dot : forall sigma ct,
      Config ct (opaqueCall dot) sigma =e=> Config ct dot sigma
  (* return context rule*)
  | Er_opaquecall_return1 : forall sigma sigma' e e' ct e'' sigma'' ,
      Config ct e sigma =e=> Config ct e' sigma' -> 
      Config ct (opaqueCall (Return e')) sigma' =e=> Config ct e'' sigma'' -> 
      Config ct (opaqueCall (Return e)) sigma =e=>  Config ct e'' sigma'' 
  (* opaque call with value, without method call inside *)
  | ST_opaquecall_val_L : forall sigma v cur_lbl ct,
      (value v) ->
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = true ->
      Config ct (opaqueCall v) sigma =e=>  Config ct (v_opa_l v cur_lbl) sigma
  | ST_opaquecall_val_H : forall sigma v cur_lbl ct sigma',
      (value v) ->
       cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = false ->
      Config ct  dot sigma =e=> Config ct  dot sigma' ->
      Config ct (opaqueCall v) sigma =e=>  Config ct dot sigma'  
  (* opaque call with return statement *)
  | ST_opaquecall_return_L : forall sigma cur_lbl v ct,
      cur_lbl = (current_label sigma) ->
      value v ->
      flow_to cur_lbl L_Label = true ->
      Config ct (opaqueCall (Return v)) sigma =e=> Config ct   (opaqueCall (Return v)) sigma
  | ST_opaquecall_return_H : forall sigma cur_lbl v ct sigma',
      cur_lbl = (current_label sigma) ->
      value v ->
      flow_to cur_lbl L_Label = false ->
      Config ct  dot sigma =e=> Config ct  dot sigma' ->
      Config ct (opaqueCall (Return v)) sigma =e=> Config ct  dot sigma'

(* assignment *)
  (* context rule *)
  | Er_assignment1 : forall sigma sigma' e e' id ct,
       Config ct e sigma =e=> Config ct e' sigma' -> 
       Config ct (Assignment id e) sigma =e=> Config ct (Assignment id e') sigma'

  (* assignment *)
  | Er_assignment_L : forall sigma id v ct cur_lbl,
      cur_lbl = (current_label sigma) ->
      value v ->
      flow_to cur_lbl L_Label = true ->
      Config ct (Assignment id v) sigma =e=> Config ct (Assignment id v) sigma
  | Er_assignment_H : forall sigma id v ct cur_lbl,
      cur_lbl = (current_label sigma) ->
      value v ->
      flow_to cur_lbl L_Label = false ->
      Config ct (Assignment id v) sigma =e=> Config ct dot sigma

(* Field Write *)
  (* context rule 1 *)
  | Er_fieldWrite1 : forall sigma sigma' f e1 e1' e2 ct,
       Config ct e1 sigma =e=> Config ct e1' sigma' -> 
       Config ct (FieldWrite e1 f e2) sigma =e=> Config ct (FieldWrite e1' f e2) sigma'
  (* context rule error 1 *)
  | Er_fieldWrite_ctx_error1 : forall sigma f e ct,
       Config ct (FieldWrite dot f e) sigma =e=> Config ct dot sigma
  (* context rule 2 *)
  | Er_fieldWrite2 : forall sigma sigma' f v e2 e2' ct,
       (forall t, value t -> t<> null -> e2 <> unlabelOpaque t) ->
       value v ->
       Config ct e2 sigma =e=> Config ct e2' sigma' -> 
       Config ct (FieldWrite v f e2) sigma =e=> Config ct (FieldWrite v f e2') sigma'
  (* field write normal *)
  | Er_fieldWrite_H : forall sigma o f v ct cur_lbl,
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = false ->
      value v->
      Config ct (FieldWrite (ObjId o) f v) sigma =e=> Config ct dot sigma
  (* field write normal *)
  | Er_fieldWrite_L : forall sigma o f v ct cur_lbl,
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = true ->
      value v->
      Config ct (FieldWrite (ObjId o) f v) sigma =e=> Config ct (FieldWrite (ObjId o) f v) sigma
  | Er_fieldWrite_dot : forall sigma o f ct cur_lbl,
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = true ->
      Config ct (FieldWrite (ObjId o) f dot) sigma =e=> Config ct (FieldWrite (ObjId o) f dot) sigma
  | Er_fieldWrite_opaque : forall sigma cur_lbl o v lo f ct,
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = true ->
      Config ct (FieldWrite (ObjId o) f (unlabelOpaque (v_opa_l v lo))) sigma =e=>
          Config ct (FieldWrite (ObjId o) f (unlabelOpaque (v_opa_l v lo))) sigma


(* return statement *)
  (* context rule*)
  | Er_return1 : forall sigma sigma' e e' ct,
        Config ct e sigma =e=> Config ct e' sigma' -> 
        Config ct (Return e) sigma =e=> Config ct (Return e') sigma'

  (* return val *)
  | Er_return_L : forall sigma v ct cur_lbl, 
      value v ->
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = true ->
      Config ct (Return v) sigma =e=> Config ct  (Return v)  sigma

  | Er_return_H : forall sigma sigma' v s s' h lsf ct cur_lbl, 
      value v ->
      sigma = SIGMA s h ->
      s = cons lsf s' ->
      s' <> nil ->
      sigma' = SIGMA s' h ->
      cur_lbl = (current_label sigma) ->
      flow_to cur_lbl L_Label = false ->
      Config ct (Return v) sigma =e=> Config ct dot sigma'

(* if statement *)
  | Er_b1 : forall sigma s1 s1' sigma' s2 id1 id2 ct, 
      Config ct s1 sigma =e=> Config ct s1' sigma' -> 
      Config ct (If id1 id2 s1 s2) sigma =e=> Config ct (If id1 id2 s1' s2) sigma'
  | Er_b2 : forall sigma s1 sigma' s2 s2' id1 id2 ct, 
      Config ct s2 sigma =e=> Config ct s2' sigma' -> 
      Config ct (If id1 id2 s1 s2) sigma =e=> Config ct (If id1 id2 s1 s2') sigma'
  | Er_b3 : forall sigma id1 id2 ct,
      Config ct (If id1 id2 dot dot) sigma =e=> Config ct dot sigma

(* sequence *)
   (* context rule *)
  | Er_seq1 : forall sigma s1 s2 s1' sigma' ct, 
    Config ct s1 sigma =e=> Config ct s1' sigma' -> 
    Config ct (Sequence s1 s2) sigma =e=> Config ct (Sequence s1' s2) sigma'
   (* sequence rule *)
  | Er_seq2 : forall sigma s ct s' sigma', 
    Config ct s sigma =e=> Config ct s' sigma' ->
    Config ct (Sequence dot s) sigma =e=> Config ct s' sigma'

(* null *)
  | Er_null_L : forall sigma ct cur_lbl,
    cur_lbl = (current_label sigma) ->
    flow_to cur_lbl L_Label = true ->
    Config ct null sigma =e=> Config ct null sigma
  | Er_null_H : forall sigma ct cur_lbl,
    cur_lbl = (current_label sigma) ->
    flow_to cur_lbl L_Label = false ->
    Config ct null sigma =e=> Config ct dot sigma


(* object o *)
  | Er_object_L : forall sigma ct cur_lbl o,
    cur_lbl = (current_label sigma) ->
    flow_to cur_lbl L_Label = true ->
    Config ct (ObjId o) sigma =e=> Config ct (ObjId o) sigma
  | Er_object_H : forall sigma ct cur_lbl o,
    cur_lbl = (current_label sigma) ->
    flow_to cur_lbl L_Label = false ->
    Config ct (ObjId o) sigma =e=> Config ct dot sigma

(* label l *)
  | Er_label_L : forall sigma ct cur_lbl lbl,
    cur_lbl = (current_label sigma) ->
    flow_to cur_lbl L_Label = true ->
    Config ct (l lbl) sigma =e=> Config ct (l lbl) sigma
  | Er_label_H : forall sigma ct cur_lbl lbl,
    cur_lbl = (current_label sigma) ->
    flow_to cur_lbl L_Label = false ->
    Config ct (l lbl) sigma =e=> Config ct dot sigma

(* v_l v lb *)
  | Er_labeled_L : forall sigma ct cur_lbl v v' lb,
    cur_lbl = (current_label sigma) ->
    flow_to cur_lbl L_Label = true ->
    Config ct v sigma =e=> Config ct v' sigma -> 
    Config ct (v_l v lb) sigma =e=> Config ct (v_l v' lb) sigma
  | Er_labeled_H : forall sigma ct cur_lbl v lb,
    cur_lbl = (current_label sigma) ->
    flow_to cur_lbl L_Label = false ->
    Config ct (v_l v lb) sigma =e=> Config ct dot sigma

(* v_l v lb *)
  | Er_v_opa_l_L : forall sigma ct cur_lbl v v' lb,
    cur_lbl = (current_label sigma) ->
    flow_to cur_lbl L_Label = true ->
    Config ct v sigma =e=> Config ct v' sigma -> 
    Config ct (v_opa_l v lb) sigma =e=> Config ct (v_opa_l v' lb) sigma
  | Er_v_opa_l_H : forall sigma ct cur_lbl v lb,
    cur_lbl = (current_label sigma) ->
    flow_to cur_lbl L_Label = false ->
    Config ct (v_opa_l v lb) sigma =e=> Config ct dot sigma

where "c '=e=>' c'" := (erasure c c').

Check erasure.




Reserved Notation "c '==l>' c'"
  (at level 40, c' at level 39).

Inductive l_reduction : config -> config -> Prop :=
(* variabel access *)
  | L_ST_var : forall id sigma s h lb sf lsf v s' ct,
      sigma = SIGMA s h ->
      s = cons lsf s' ->
      lsf = Labeled_frame lb sf ->
      Some v = sf(id) ->
      Config ct (Tvar id) sigma ==l> Config ct v sigma

(* field read *)
  (* context rule *)
  | L_ST_fieldRead1 : forall sigma sigma' e e' f ct,
      Config ct e sigma ==l>  Config ct e' sigma' -> 
      Config ct (FieldAccess e f) sigma ==l> Config ct (FieldAccess e' f) sigma'
  (* normal field access *)
  | L_ST_fieldRead2 : forall sigma sigma' o s h fname lb cls fields v l' s' ct,
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls fields lb) = lookup_heap_obj h o -> 
      Some v = fields(fname) -> 
      l' = join_label lb (current_label sigma) ->
      s' = update_current_label s l'-> 
      sigma' = SIGMA s' h ->
      Config ct (FieldAccess (ObjId o) fname) sigma ==l> Config ct v sigma'



(* method call *)
  (* context rule: evaluate object target *)
  | L_ST_MethodCall1 : forall sigma sigma' e e' e2 id ct,
       Config ct e sigma ==>  Config ct e' sigma' -> 
      Config ct (MethodCall e id e2) sigma ==l> Config ct (MethodCall e' id e2)  sigma'
  (* context rule: evaluate arguments *)
  | L_ST_MethodCall2 : forall sigma sigma' v e e' id ct,
      (forall t, value t -> t<> null -> e <> unlabelOpaque t) ->
      Config ct e sigma ==l>  Config ct e' sigma' -> 
      value v ->
      Config ct (MethodCall v id e) sigma ==l> Config ct (MethodCall v id e') sigma'
  (* normal method call *)
  | L_ST_MethodCall3 : forall sigma sigma' o s h cls fields v lx l s' sf lsf arg_id cls_a body meth returnT ct,
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls fields lx) = lookup_heap_obj h o -> 
      Some (m_def returnT meth cls_a arg_id (Return body)) = find_method cls meth -> 
      value v ->
      sf = sf_update empty_stack_frame arg_id v ->
      l = (current_label sigma) ->
      lsf = Labeled_frame l sf ->
      s' = cons lsf s ->
      sigma' = SIGMA s' (get_heap sigma) ->
      Config ct (MethodCall (ObjId o) meth v) sigma ==l>  Config ct (Return body) sigma'


(* method call with unlabel opaque *)
  | L_ST_MethodCall_unlableOpaque : forall sigma sigma' o s h cls fields v lx l' lb s' sf lsf arg_id cls_a body meth returnT ct,
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls fields lx) =lookup_heap_obj h o -> 
      sf = sf_update empty_stack_frame arg_id v ->
      l' = join_label lb (current_label sigma) ->
      lsf = Labeled_frame l' sf ->
      s' = cons lsf s ->
      value v ->
      Some (m_def returnT meth cls_a arg_id  (Return body)) = find_method cls meth ->
      sigma' = SIGMA s' (get_heap sigma) ->
      Config ct (MethodCall (ObjId o) meth (unlabelOpaque (v_opa_l v lb)))  sigma ==l>Config ct (Return body) sigma'

(* new expression *)
  | L_ST_NewExp : forall sigma sigma' h h' s o lb cls_name field_defs method_defs cls F ct,
      ct cls_name = Some cls ->
      sigma = SIGMA s h->
      lb = (current_label sigma) -> 
      o = get_fresh_oid h ->
      cls = (class_def cls_name field_defs method_defs) ->
      F =  (init_field_map (find_fields cls) empty_field_map) ->
      h' = add_heap_obj h o (Heap_OBJ cls F lb) ->
      sigma' = SIGMA s h' ->
      Config ct (NewExp cls_name) sigma ==l> Config ct (ObjId o) sigma'


(* label data express *)
  (* context rule *)
  | L_ST_LabelData1 : forall sigma sigma' e e' lb ct,
      Config ct e sigma ==l>  Config ct e' sigma' -> 
      Config ct (labelData e lb) sigma ==l> Config ct (labelData e' lb) sigma'
  (* label data *)
  | L_ST_LabelData2 : forall sigma v lb ct,
      value v ->
      Config ct (labelData v lb) sigma ==l>  Config ct (v_l v lb)  sigma

(* unlabel *)
  (* context rule *)
  | L_ST_unlabel1 : forall sigma sigma' e e' ct,
      Config ct e sigma ==l>  Config ct e' sigma' -> 
      Config ct  (unlabel e) sigma ==l> Config ct (unlabel e') sigma'
  (* unlabel *)
  | L_ST_unlabel2 : forall sigma v lb l' sigma' s h s' ct,
      sigma = SIGMA s h ->
      l' = join_label lb (current_label sigma) ->
      s' = update_current_label s l'-> 
      sigma' = SIGMA s' (get_heap sigma) ->
      value v ->
      Config ct (unlabel (v_l v lb)) sigma ==l> Config ct v sigma'


(* Label of *)
  (* context rule *)
  | L_ST_labelof1 : forall sigma sigma' e e' ct,
       Config ct e sigma ==l>  Config ct e' sigma' -> 
       Config ct (labelOf e) sigma ==l> Config ct (labelOf e') sigma'
  (* label of  *)
  | L_ST_labelof2 : forall sigma v lb ct,
      Config ct (labelOf (v_l v lb)) sigma ==l> Config ct (l lb) sigma


(* unlabel opaque*)
  (* context rule *)
  | L_ST_unlabel_opaque1 : forall sigma sigma' e e' ct,
      Config ct e sigma ==l>  Config ct e' sigma' -> 
     Config ct (unlabelOpaque e) sigma ==l>  Config ct (unlabelOpaque e') sigma'

  (* unlabel opaque *)
  | L_ST_unlabel_opaque2 : forall sigma v lb l' sigma' s h s'  ct,
      sigma = SIGMA s h ->
      l' = join_label lb (current_label sigma) ->
      s' = update_current_label s l'-> 
      sigma' = SIGMA s' (get_heap sigma) ->
      Config ct (unlabelOpaque (v_opa_l v lb)) sigma ==l> Config ct v sigma'


(* Opaque call *)
  (* context rule *)
  | L_ST_opaquecall1 : forall sigma sigma' e e' ct,
       (forall v, value v -> e <> Return v) ->
       Config ct e sigma ==l>  Config ct e' sigma' -> 
      Config ct (opaqueCall e) sigma ==l> Config ct (opaqueCall e') sigma'
  (* return context rule*)
  | L_ST_opaquecall_return1 : forall sigma sigma' e e' ct,
       Config ct e sigma ==l> Config ct e' sigma' -> 
      Config ct (opaqueCall (Return e)) sigma ==l> Config ct (opaqueCall (Return e')) sigma'



  (* opaque call with value, without method call inside *)
  | L_ST_opaquecall_val2 : forall sigma v lb ct,
      (value v) ->
      lb = (current_label sigma) ->
      Config ct (opaqueCall v) sigma ==l>  Config ct (v_opa_l v lb) sigma  
  (* opaque call with return statement *)
  | L_ST_opaquecall_return2 : forall sigma sigma' s h lb s' lsf v ct,
      sigma = SIGMA s h->
      s = cons lsf s' ->
      s' <> nil ->
      lb = (current_label sigma) ->
      sigma' = SIGMA s' h->
      value v ->
      Config ct (opaqueCall (Return v)) sigma ==l> Config ct  (v_opa_l v lb) sigma'


(* assignment *)
  (* context rule *)
  | L_ST_assignment1 : forall sigma sigma' e e' id ct,
       Config ct e sigma ==l> Config ct e' sigma' -> 
       Config ct (Assignment id e) sigma ==l> Config ct (Assignment id e') sigma'
  (* assignment *)
  | L_ST_assignment2 : forall sigma sigma' id v s' s h ct,
       value v ->
       sigma = SIGMA s h ->
       s' = update_stack_top s id v->
       sigma' = SIGMA s' h ->
       Config ct (Assignment id v) sigma ==l> Config ct Skip sigma'

(* Field Write *)
  (* context rule 1 *)
  | L_ST_fieldWrite1 : forall sigma sigma' f e1 e1' e2 ct,
       Config ct e1 sigma ==l> Config ct e1' sigma' -> 
       Config ct (FieldWrite e1 f e2) sigma ==l> Config ct (FieldWrite e1' f e2) sigma'

  (* context rule 2 *)
  | L_ST_fieldWrite2 : forall sigma sigma' f v e2 e2' ct,
       (forall t, value t -> t<> null -> e2 <> unlabelOpaque t) ->
       value v ->
       Config ct e2 sigma ==l> Config ct e2' sigma' -> 
       Config ct (FieldWrite v f e2) sigma ==l> Config ct (FieldWrite v f e2') sigma'

  (* field write normal *)
  | L_ST_fieldWrite3 : forall sigma sigma' o s h h' f lb cls F F' v l' ct,
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls F lb) = lookup_heap_obj h o -> 
      F' = fields_update F f v ->
      l' = join_label lb (current_label sigma) ->
      h' = update_heap_obj h o (Heap_OBJ cls F' l') ->
      sigma' = SIGMA s h' ->
      value v->
      Config ct (FieldWrite (ObjId o) f v) sigma ==l> Config ct Skip sigma'

  (* field write normal *)
  | L_ST_fieldWrite_opaque : forall sigma sigma' o s h h' f lo cls F F' v l' lb e2 ct,
      e2 = unlabelOpaque (v_opa_l v lb) ->
      sigma = SIGMA s h ->
      Some (Heap_OBJ cls F lo) = lookup_heap_obj h o-> 
      F' = fields_update F f v ->
      l' = join_label lo lb ->
      h' = update_heap_obj h o (Heap_OBJ cls F' l') ->
      sigma' = SIGMA s h' ->
      value v ->
      Config ct (FieldWrite (ObjId o) f e2) sigma ==l> Config ct Skip sigma'

(* return statement *)
  (* context rule*)
  | L_ST_return1 : forall sigma sigma' e e' ct,
        Config ct e sigma ==l> Config ct e' sigma' -> 
        Config ct (Return e) sigma ==l> Config ct (Return e') sigma'

  (* return val *)
  | L_ST_return2 : forall sigma sigma' v s s' s'' h lsf l' ct, 
      value v ->
      sigma = SIGMA s h ->
      s = cons lsf s' ->
      s' <> nil ->
      l' = join_label (get_current_label s) (get_current_label s') ->
      s'' = update_current_label s' l' ->
      sigma' = SIGMA s'' h ->
      Config ct (Return v) sigma ==l> Config ct v sigma'


(* if statement *)
  | L_ST_if_b1 : forall sigma s1 s2 s h lsf s' lb sf id1 id2 ct, 
       sigma = SIGMA s h ->
       s = cons lsf s' ->
       lsf = Labeled_frame lb sf ->
       sf(id1) = sf(id2) ->
       Config ct (If id1 id2 s1 s2) sigma ==l> Config ct s1 sigma
  | L_ST_if_b2 : forall sigma s1 s2 s h lsf s' lb sf id1 id2 ct, 
       sigma = SIGMA s h ->
       s = cons lsf s' ->
       lsf = Labeled_frame lb sf ->
       sf(id1) <> sf(id2) ->
       Config ct (If id1 id2 s1 s2) sigma ==l> Config ct s2 sigma
(* sequence *)
   (* context rule *)
  | L_ST_seq1 : forall sigma s1 s2 s1' sigma' ct, 
    Config ct s1 sigma ==l> Config ct s1' sigma' -> 
    Config ct (Sequence s1 s2) sigma ==l> Config ct (Sequence s1' s2) sigma'
   (* sequence rule *)
  | L_ST_seq2 : forall sigma v s ct, 
    value v->
    Config ct (Sequence v s) sigma ==l> Config ct s sigma

where "c '==l>' c'" := (l_reduction c c').






Inductive erasure_sigma : Sigma -> Sigma -> Prop :=
   | empty_stack_erasure : forall s s' sigma sigma' h, 
          sigma = SIGMA s h->
          sigma' = SIGMA s' h->
          s = nil ->
          s' = nil ->
          erasure_sigma sigma sigma'
   | stack_erasure : forall s s' s0 s0' sf' sf lb h sigma sigma',
          sigma = SIGMA s h->
          sigma' = SIGMA s' h->
          s = cons (Labeled_frame lb sf) s0 ->
          s' = cons (Labeled_frame lb sf') s0' ->
          (forall x v, 
  (* needs revision *)
              sf x = Some v ->
              sf' x = Some v )->
          erasure_sigma (SIGMA s0 h) (SIGMA s0' h) -> 
          erasure_sigma sigma sigma'.

Inductive L_equivalence_object : oid -> heap -> oid -> heap -> Prop :=
   | object_equal_H : forall o1 o2 h1 h2 lb1 lb2 cls1 cls2 F1 F2,
        Some (Heap_OBJ cls1 F1 lb1) = lookup_heap_obj h1 o1 -> 
        Some (Heap_OBJ cls2 F2 lb2) = lookup_heap_obj h2 o2 ->
        flow_to lb1 L_Label = false ->
        flow_to lb2 L_Label = false ->
        L_equivalence_object o1 h1 o2 h2
   | object_equal_L : forall o1 o2 h1 h2 lb1 lb2 cls1 cls2 F1 F2,
        Some (Heap_OBJ cls1 F1 lb1) = lookup_heap_obj h1 o1 -> 
        Some (Heap_OBJ cls2 F2 lb2) = lookup_heap_obj h2 o2 ->
        flow_to lb1 L_Label = true ->
        flow_to lb2 L_Label = true ->
        ((cls1 = cls2) /\ (lb1 = lb2) /\ 
            (forall fname, F1 fname = Some null -> F2 fname = Some null ) /\
            (forall fname fo1 fo2, F1 fname = Some (ObjId fo1) -> F2 fname = Some (ObjId fo2) ->
              L_equivalence_object fo1 h1 fo2 h2 )
        )-> L_equivalence_object o1 h1 o2 h2.

Inductive L_equivalence_tm : tm -> heap -> tm -> heap -> Prop :=
  | L_equivalence_tm_eq_Tvar : forall id1 id2 h1 h2, 
      id1 = id2 -> L_equivalence_tm (Tvar id1) h1 (Tvar id2) h2
  | L_equivalence_tm_eq_null : forall h1 h2,  
      L_equivalence_tm null h1 null h2
  | L_equivalence_tm_eq_fieldaccess : forall e1 e2 f h1 h2,
      L_equivalence_tm e1 h1 e2 h2 ->
      L_equivalence_tm (FieldAccess e1 f) h1 (FieldAccess e2 f) h2
  | L_equivalence_tm_eq_methodcall : forall e1 e2 a1 a2 meth h1 h2,
      L_equivalence_tm e1 h1 e2 h2->
      L_equivalence_tm a1 h1 a2 h2 ->
      L_equivalence_tm (MethodCall e1 meth a1) h1 (MethodCall e1 meth a1) h2
  | L_equivalence_tm_eq_newexp : forall cls1 cls2 h1 h2,
      cls1 = cls2 ->
      L_equivalence_tm (NewExp cls1) h1 (NewExp cls2) h2
  | L_equivalence_tm_eq_label : forall l1 l2 h1 h2, 
      l1 = l2 ->
      L_equivalence_tm (l l1) h1 (l l2) h2
  | L_equivalence_tm_eq_labelData : forall e1 e2 l1 l2 h1 h2,
      L_equivalence_tm e1 h1 e2 h2->
      l1 = l2 ->
      L_equivalence_tm (labelData e1 l1) h1 (labelData e2 l2) h2
  | L_equivalence_tm_eq_unlabel : forall e1 e2 h1 h2,
      L_equivalence_tm e1 h1 e2 h2->
      L_equivalence_tm (unlabel e1) h1 (unlabel e2) h2
  | L_equivalence_tm_eq_labelOf : forall e1 e2 h1 h2,
      L_equivalence_tm e1 h1 e2 h2 ->
      L_equivalence_tm (labelOf e1) h1 (labelOf e2) h2
  | L_equivalence_tm_eq_unlabelOpaque : forall e1 e2 h1 h2,
      L_equivalence_tm e1 h1 e2 h2 ->
      L_equivalence_tm (unlabelOpaque e1) h1 (unlabelOpaque e2) h2
  | L_equivalence_tm_eq_opaqueCall : forall e1 e2 h1 h2,
      L_equivalence_tm e1 h1 e2 h2 ->
      L_equivalence_tm (opaqueCall e1) h1 (opaqueCall e2) h2
  | L_equivalence_tm_eq_skip : forall h1 h2,
      L_equivalence_tm Skip h1 Skip h2
  | L_equivalence_tm_eq_Assignment : forall e1 e2 x1 x2 h1 h2, 
      L_equivalence_tm e1 h1 e2 h2 ->
      x1 = x2->
      L_equivalence_tm (Assignment x1 e1) h1 (Assignment x2 e2) h2
  | L_equivalence_tm_eq_FieldWrite : forall e1 e2 f1 f2 e1' e2' h1 h2,
      L_equivalence_tm e1 h1 e2 h2 ->
      f1 = f2 ->
      L_equivalence_tm e1' h1 e2' h2 ->
      L_equivalence_tm (FieldWrite e1 f1 e1') h1 (FieldWrite e2 f2 e2') h2
  | L_equivalence_tm_eq_if : forall s1 s2 s1' s2' id1 id2 id1' id2' h1 h2,
      L_equivalence_tm s1 h1 s1' h2 ->
      L_equivalence_tm s2 h1 s2' h2 ->
      id1 = id1' ->
      id2 = id2' ->
      L_equivalence_tm (If id1 id2 s1 s2) h1 (If id1' id2' s1' s2') h2
  | L_equivalence_tm_eq_Sequence : forall s1 s2 s1' s2' h1 h2, 
      L_equivalence_tm s1 h1 s1' h2 ->
      L_equivalence_tm s2 h1 s2' h2->
      L_equivalence_tm (Sequence s1 s2) h1 (Sequence s1' s2') h2
  | L_equivalence_tm_eq_sequence_dot1 : forall s1 s2 h1 h2, 
      L_equivalence_tm s1 h1 s2 h2 ->
      L_equivalence_tm s1 h1 (Sequence dot s2) h2
  | L_equivalence_tm_eq_sequence_dot2 : forall s1 s2 h1 h2, 
      L_equivalence_tm s1 h1 s2 h2 ->
      L_equivalence_tm (Sequence dot s1) h1 s2 h2
  | L_equivalence_tm_eq_return : forall e1 e2 h1 h2,  
      L_equivalence_tm e1 h1 e2 h2 ->
      L_equivalence_tm (Return e1) h1 (Return e2) h2
  | L_equivalence_tm_eq_object : forall o1 o2 h1 h2, 
      L_equivalence_object o1 h1 o2 h2 ->
      L_equivalence_tm (ObjId o1) h1 (ObjId o2) h2
  | L_equivalence_tm_eq_v_l_L : forall lb e1 e2 h1 h2, 
      flow_to lb L_Label = true ->
      L_equivalence_tm e1 h1 e2 h2 ->
      L_equivalence_tm (v_l e1 lb) h1 (v_l e2 lb) h2
  | L_equivalence_tm_eq_v_l_H : forall e1 e2 l1 l2 h1 h2, 
      flow_to l1 L_Label = false ->
      flow_to l2 L_Label = false ->
      L_equivalence_tm (v_l e1 l1) h1 (v_l e2 l2) h2
  | L_equivalence_tm_eq_v_opa_l_L : forall lb e1 e2 h1 h2, 
      flow_to lb L_Label = true ->
      L_equivalence_tm e1 h1 e2 h2 ->
      L_equivalence_tm (v_opa_l e1 lb) h1 (v_opa_l e2 lb) h2
  | L_equivalence_tm_eq_v_opa_l_H : forall e1 e2 l1 l2 h1 h2, 
      flow_to l1 L_Label = false ->
      flow_to l2 L_Label = false ->
      L_equivalence_tm (v_opa_l e1 l1) h1 (v_opa_l e2 l2) h2
  | L_equivalence_tm_eq_dot : forall h1 h2,
      L_equivalence_tm (dot) h1 (dot) h2.


Inductive L_equivalence_store : stack -> heap -> stack -> heap -> Prop :=
  | L_equivalence_empty : forall lb h h', 
      L_equivalence_store (cons (Labeled_frame lb empty_stack_frame) nil) h
                                       (cons (Labeled_frame lb empty_stack_frame) nil) h'
  | L_equivalence_equal_store : forall s h,
      L_equivalence_store s h s h
  | L_equivalence_store_L : forall s1 lb1 sf1 s0 s2 lb2 sf2 s0' h1 h2 v1 v2, 
      s1 = cons (Labeled_frame lb1 sf1) s0->
      s2 = cons (Labeled_frame lb2 sf2) s0'->
      L_equivalence_store s0 h1 s0' h2 ->
      flow_to lb1 L_Label = true ->
      flow_to lb2 L_Label = true ->
      (forall x, sf1 x = Some v1 -> sf2 x = Some v2 -> L_equivalence_tm v1 h1 v2 h2) ->
      L_equivalence_store s1 h1 s2 h2.



Inductive multi_step_reduction : config -> config -> Prop := 
  | multi_reduction_refl : forall config , multi_step_reduction config config
  | multi_reduction_step : forall c1 c2 c3, 
                    reduction c1 c2 ->
                    multi_step_reduction c2 c3 ->
                    multi_step_reduction c1 c3.

Inductive multi_step : Class_table -> tm -> Sigma -> Class_table-> tm -> Sigma -> Prop := 
  | multi_refl : forall t ct sigma , multi_step ct t sigma ct t sigma
  | multi_reduction : forall t1 t2 t3 sigma1 sigma2 sigma3 ct, 
                    reduction (Config ct t1 sigma1) (Config ct t2 sigma2) ->
                    multi_step ct t2 sigma2 ct t3 sigma3 ->
                    multi_step ct t1 sigma1 ct t3 sigma3.

Notation "c1 '==>*' c2" := (multi_step_reduction c1 c2) (at level 40).

(* unrestricted access L *)
Definition H_Label := LB (cons (Principal "Jian") nil).

Inductive multi_step_l_reduction : config -> config -> Prop := 
  | multi_reduction_l_refl : forall config , multi_step_l_reduction config config
  | multi_reduction_l_step : forall c1 c2 c3, 
                    l_reduction c1 c2 ->
                    multi_step_l_reduction c2 c3 ->
                    multi_step_l_reduction c1 c3.

Notation "c1 '==>L*' c2" := (multi_step_l_reduction c1 c2) (at level 40).



Theorem L_reduction_determinacy: forall ct t sigma t1 sigma1 t2 sigma2, 
     l_reduction (Config ct t sigma) (Config ct t1 sigma1) ->
     l_reduction (Config ct t sigma) (Config ct t2 sigma2) -> 
      t1 = t2 /\ sigma1 = sigma2. 
Proof.
Admitted. 

Lemma normal_form_prime : forall v sigma ct, value v->
(forall v' sigma', Config ct v sigma ==> Config ct v' sigma' -> False).
Proof. 
  intros v sigma ct. intro H_v. intros.
  inversion H_v; try (rewrite <-H0 in H; inversion H; fail); 
  try (rewrite <-H1 in H; inversion H).
Qed.

Lemma normal_form_L_reduction : forall v sigma ct, value v->
(forall v' sigma', Config ct v sigma ==l> Config ct v' sigma' -> False).
Proof. 
  intros v sigma ct. intro H_v. intros.
  inversion H_v; try (rewrite <-H0 in H; inversion H; fail); 
  try (rewrite <-H1 in H; inversion H).
Qed.

Lemma ct_consist : forall CT CT' t t' sigma sigma', 
  Config CT t sigma ==> Config CT' t' sigma' -> CT = CT'. 
 Proof.
   intros. induction t; inversion H; auto. 
  Qed. 

Lemma l_reduction_ct_consist : forall CT CT' t t' sigma sigma', 
  Config CT t sigma ==l> Config CT' t' sigma' -> CT = CT'. 
 Proof.
   intros. induction t; inversion H; auto. 
  Qed. 

Theorem L_reduction_multistep_determinacy: forall ct t sigma v1 sigma1 v2 sigma2, 
     multi_step_l_reduction (Config ct t sigma) (Config ct v1 sigma1) ->
     multi_step_l_reduction (Config ct t sigma) (Config ct v2 sigma2) -> 
     value v1 -> value v2 ->
      v1 = v2 /\ sigma1 = sigma2. 
Proof.
  intros ct t sigma v1 sigma1 v2 sigma2 Hy1 Hy2.
  remember (Config ct v1 sigma1) as v1_config. intro Hv1. intro Hv2.  
  generalize dependent v1.      generalize dependent v2.
  induction Hy1.
  - intro v2. intro. intro v1. intro. intro. intro.  
    induction config0; auto. inversion Heqv1_config. subst.
    inversion Hy2. subst. auto. induction c2. assert (ct = c). 
    apply l_reduction_ct_consist with v0  t0 sigma1 s. auto.  subst. 
    apply normal_form_L_reduction with  (v:=v0) (sigma:=sigma1) (ct:=c) in H; intuition.

    inversion H. inversion Heqv1_config. 

  - intros. inversion Hy2. subst. induction c2. 
    assert (ct = c). 
    apply l_reduction_ct_consist with v2  t0 sigma2 s. auto.  subst. 
    apply normal_form_L_reduction with  (v:=v2) (sigma:=sigma2) (ct:=c) in H; intuition.

    inversion H. 
    induction c1. induction c2.  induction c4. 
    assert (t1 = t2 /\ s0 = s1 ). 
    assert (c = c1). 
    apply l_reduction_ct_consist with t0 t1 s s0. auto.  
    assert (c = c2). 
    apply l_reduction_ct_consist with t0 t2 s s1. auto. subst. 
    apply L_reduction_determinacy with  (ct:=c2) (t:=t0) (sigma:=s) 
          (t1:=t1) (sigma1:=s0) (t2:=t2) (sigma2:=s1);  subst; auto.
    destruct H4. subst. 
    assert (c = c1). 
    apply l_reduction_ct_consist with t0 t2 s s1. auto.  
    assert (c = c2). 
    apply l_reduction_ct_consist with t0 t2 s s1. auto. subst. apply IHHy1; auto.
    inversion H0. subst.  inversion H. inversion H.
Qed.

Lemma simulation_L : forall CT t t0 t' t0' sigma_l sigma_r sigma_l_e sigma_r_e s h,
      sigma_l = SIGMA s h ->
      field_wfe_heap CT h -> wfe_heap CT h -> wfe_stack CT h s ->
      flow_to (current_label sigma_l) L_Label = true ->
      Config CT t sigma_l ==> Config CT t' sigma_r ->
      (erasure (Config CT t sigma_l) (Config CT t0 sigma_l_e)) ->
      (erasure (Config CT t' sigma_r) (Config CT t0' sigma_r_e)) ->
      l_reduction (Config CT t0 sigma_l_e) (Config CT t0' sigma_r_e).
Proof. 
  intros CT t t0 t' t0' sigma_l sigma_r sigma_l_e sigma_r_e s h.
  intro H_sigma. intro H_wfe_fields. 
  intro H_wfe_heap. intro H_wfe_stack. intro H_flow. intro H_reduction. 
  (*intro H_erasure_sigma_l.  *) intro H_erasure_l. intro H_erasure_r.  
    generalize dependent t0.     generalize dependent t0'. induction H_reduction; subst.
 
(*Tvar *)
  (*- admit.  inversion H_erasure_l.
      + subst. inversion H_wfe_stack. rewrite <- H4 in H3. inversion H3. 
          rewrite <- H9 in H7.  inversion H7.
        subst. inversion H2. inversion H. inversion H3. subst. destruct H4 with id0 t'. auto. 
        rewrite H5 in H_erasure_r. inversion H_erasure_r. subst. 
         apply L_ST_var with (s:= (Labeled_frame lb sf :: s')) (h:=h0) (lb:=lb) 
                (sf:=sf) (lsf:=(Labeled_frame lb sf)) (s':=s'); auto.
         subst. rewrite H6 in H13. inversion H13. 

         destruct H5 as [cls_name].          destruct H5 as [o]. destruct H5.  
         rewrite H5 in H_erasure_r. inversion H_erasure_r. subst. 
         apply L_ST_var with (s:= (Labeled_frame lb sf :: s')) (h:=h0) (lb:=lb) 
                (sf:=sf) (lsf:=(Labeled_frame lb sf)) (s':=s'); auto.
         subst. rewrite H6 in H15. inversion H15. 
    + subst. rewrite H_flow in H6. inversion H6. 

  - intro t0'. intro. intro t0. intro.    inversion H_erasure_l. 
    + subst. inversion H_erasure_r. subst. 
      *)
Admitted. 

(*
Lemma simulation_H : forall CT t t0 t' t0' sigma_l sigma_r sigma_l_e sigma_r_e,
      flow_to (current_label sigma_l) L_Label = false ->
      Config CT t sigma_l ==> Config CT t' sigma_r ->
      (erasure (Config CT t sigma_l) (Config CT t0 sigma_l_e)) ->
      (erasure (Config CT t' sigma_r) (Config CT t0' sigma_r_e)) ->
      (Config CT t0 sigma_l_e) = (Config CT t0' sigma_r_e).
Proof. 
  intros CT t t0 t' t0' sigma_l sigma_r sigma_l_e sigma_r_e.
  intro H_flow. intro H_reduction. 
  (*intro H_erasure_sigma_l.  *) intro H_erasure_l. intro H_erasure_r.  
    remember (Config CT t sigma_l ) as config.     remember (Config CT t' sigma_r) as config'. 
generalize dependent t0'. generalize dependent t0. generalize dependent t. generalize dependent sigma_l.
generalize dependent t'. generalize dependent sigma_r.  
    generalize dependent sigma_l_e.      generalize dependent sigma_r_e.
    induction H_reduction; subst.
    - intros. inversion Heqconfig.   inversion H_erasure_l. subst. rewrite H_flow in H10.  
      inversion H10.  
*)

Lemma simulation_H : forall CT t t0 t' t0' sigma_l sigma_r sigma_l_e sigma_r_e s h,
      sigma_l = SIGMA s h ->
      field_wfe_heap CT h -> wfe_heap CT h -> wfe_stack CT h s ->
      flow_to (current_label sigma_l) L_Label = false ->
      Config CT t sigma_l ==> Config CT t' sigma_r ->
      (erasure (Config CT t sigma_l) (Config CT t0 sigma_l_e)) ->
      (erasure (Config CT t' sigma_r) (Config CT t0' sigma_r_e)) ->
      (Config CT t0 sigma_l_e) = (Config CT t0' sigma_r_e).
Proof. 
  intros CT t t0 t' t0' sigma_l sigma_r sigma_l_e sigma_r_e s h.
  intro H_sigma. intro H_wfe_fields. 
  intro H_wfe_heap. intro H_wfe_stack. intro H_flow. intro H_reduction. 
  (*intro H_erasure_sigma_l.  *) intro H_erasure_l. intro H_erasure_r.  
    remember (Config CT t sigma_l ) as config.     remember (Config CT t' sigma_r) as config'. 
generalize dependent t0'. generalize dependent t0. generalize dependent t. generalize dependent sigma_l.
generalize dependent t'. generalize dependent sigma_r.
    generalize dependent sigma_l_e.      generalize dependent sigma_r_e.
generalize dependent s. generalize dependent h.
    induction H_reduction; subst.
    - intros. inversion Heqconfig.  inversion H_erasure_l. inversion H3. subst.  
          inversion H11.  subst. rewrite H_flow in H10. inversion H10.
       subst.  
        inversion H_wfe_stack. inversion H3. rewrite <-H5 in H8. inversion H8.
        rewrite H12 in H2. inversion H2. 

       inversion H4. inversion H3. rewrite H in H16. inversion H16. inversion H9. subst. 
        destruct H11 with id0 v. auto. rewrite H in H_erasure_r. inversion H_erasure_r. 
        rewrite H12 in H14.  rewrite H10 in H14. inversion H14. 
        auto.  
        destruct H as [cls_name]. destruct H as [o]. destruct H.
        rewrite H in H_erasure_r. inversion H_erasure_r. 
        rewrite H12 in H17.  rewrite H10 in H17. inversion H17. 
        auto. 
    -  intros. inversion Heqconfig.  inversion H_erasure_l. subst. induction sigma'.  

Admitted. 

Lemma excluded_middle_label : forall lb, (flow_to lb L_Label = true) \/ (flow_to lb L_Label = false).
Proof with eauto.
  intros. case lb. intro principal. induction principal. unfold L_Label. 
  unfold flow_to. left.  unfold subset. auto.
     unfold L_Label.   unfold flow_to. left. unfold subset. auto.
Qed. 

Lemma erasure_equal_input : forall ct t s h s' h' sigma_r sigma_r' t_r t_r', 
      L_equivalence_store s h s' h' ->
      erasure (Config ct t (SIGMA s h)) (Config ct t_r sigma_r) -> 
      erasure (Config ct t (SIGMA s' h')) (Config ct t_r' sigma_r') -> 
      (Config ct t_r sigma_r) = (Config ct t_r' sigma_r').
Proof. Admitted. 

Lemma erasue_target : forall ct t sigma, 
    exists t' sigma', erasure (Config ct t sigma) (Config ct t' sigma').
  Proof. intros ct t sigma. 
   induction t. 
   Admitted. 

Theorem preservation : forall CT s s' h h' sigma sigma',
    field_wfe_heap CT h -> sigma = SIGMA s h ->  
    wfe_heap CT h -> wfe_stack CT h s -> sigma' = SIGMA s' h' -> 
    forall t T, has_type CT empty_context h t T -> 
     forall t',  Config CT t sigma ==> Config CT t' sigma' ->
     ( has_type CT empty_context h' t' T) .
Proof. Admitted. 


Lemma error_state_cannot_reach_valid_state : forall ct t sigma, 
    ~ (Error_state ==>* Config ct t sigma).
Proof. 
  intros. intro contra. induction t; inversion contra; inversion H. 
Qed. 


Lemma multi_step_simulation : forall CT t t0 t' t0' sigma_l sigma_r sigma_l_e sigma_r_e s h,
      sigma_l = SIGMA s h ->
      field_wfe_heap CT h -> wfe_heap CT h -> wfe_stack CT h s ->
      Config CT t sigma_l ==>* Config CT t' sigma_r ->
      (erasure (Config CT t sigma_l) (Config CT t0 sigma_l_e)) ->
      (erasure (Config CT t' sigma_r) (Config CT t0' sigma_r_e)) ->
      forall T, has_type CT empty_context h t T -> 
      (Config CT t0 sigma_l_e) ==>L* (Config CT t0' sigma_r_e).
Proof.
    intros CT t t0 t' t0' sigma_l sigma_r sigma_l_e sigma_r_e s h.
    intro H_sigma_l.  intro H_wfe_field. intro H_wfe_heap. intro H_wfe_stack.
    intro H_multistep_reduction. intro H_erasure_l. intro H_erasure_r. intro T. intro H_typing. 
    

    remember (Config CT t sigma_l) as t_config. 
    remember (Config CT t' sigma_r) as t'_config. 

generalize dependent t0'. generalize dependent t0. generalize dependent t. generalize dependent sigma_l.
generalize dependent t'. generalize dependent sigma_r.
    generalize dependent sigma_l_e.      generalize dependent sigma_r_e.
generalize dependent s. generalize dependent h.
induction H_multistep_reduction.
  intros. 
  assert ((Config CT t0 sigma_l_e) = (Config CT t0' sigma_r_e)).
  apply erasure_equal_input with t s h s h.
  apply L_equivalence_equal_store.
  rewrite Heqt_config in H_erasure_l. 
  rewrite <- H_sigma_l.  auto.
  rewrite Heqt_config in H_erasure_r. 
  rewrite <- H_sigma_l.  auto. 
  rewrite H. apply multi_reduction_l_refl.


  intros.   induction c2. 
  assert ( exists t1_r s0_r, erasure (Config c t1 s0) (Config c t1_r s0_r)).
  apply erasue_target. destruct H0 as [t1_r]. destruct H0 as [s0_r].

    remember (current_label (SIGMA s h)) as cur_lbl.
    assert ((flow_to cur_lbl L_Label = true) \/ (flow_to cur_lbl L_Label = false)).
    apply excluded_middle_label.  destruct H1.

 apply multi_reduction_l_step with (Config c t1_r s0_r).
  assert (CT=c). apply ct_consist with t t1 sigma_l s0. 
  rewrite Heqt_config in H. auto. subst. 



  apply simulation_L with (CT:=c) (t:=t) (t0:=t0) (t':=t1) (t0':=t1_r) 
      (sigma_l:=(SIGMA s h)) (sigma_r:=s0) (sigma_l_e:=sigma_l_e) (s:=s) (h:=h); auto.
  subst. induction s0.
assert (CT=c). apply ct_consist with t t1 (SIGMA s h) (SIGMA s0 h0); auto.  
subst; auto.  

assert (wfe_heap c h0 /\ wfe_stack c h0 s0 /\  field_wfe_heap c h0).
apply reduction_preserve_wfe with s h (SIGMA s h) (SIGMA s0 h0) t
T t1; auto. 
destruct IHH_multistep_reduction with (h:=h0) (s:=s0) (sigma_r_e:=sigma_r_e)
       (sigma_l_e:=s0_r) (t0':=t0')
(sigma_r0:=sigma_r) (t'0:=t') (sigma_l:=(SIGMA s0 h0)) (t:=t1) (t0:= t1_r). 
apply H2.  apply H2. apply H2. auto. auto. auto. 
apply preservation with s s0 h (SIGMA s h) (SIGMA s0 h0) t; auto.
auto. auto. apply multi_reduction_l_refl. apply multi_reduction_l_step with c2; auto.





subst. induction s0.
assert (CT=c). apply ct_consist with t t1 (SIGMA s h) (SIGMA s0 h0); auto.  
subst; auto.  

assert (wfe_heap c h0 /\ wfe_stack c h0 s0 /\  field_wfe_heap c h0).
apply reduction_preserve_wfe with s h (SIGMA s h) (SIGMA s0 h0) t
T t1; auto. 
assert (Config c t1_r s0_r ==>L* Config c t0' sigma_r_e).
apply IHH_multistep_reduction with (h:=h0) (s:=s0) (sigma_r_e:=sigma_r_e)
       (sigma_l_e:=s0_r) (t0':=t0')
(sigma_r0:=sigma_r) (t'0:=t') (sigma_l:=(SIGMA s0 h0)) (t:=t1) (t0:= t1_r); auto. 
apply H2.  apply H2. apply H2.
apply preservation with s s0 h (SIGMA s h) (SIGMA s0 h0) t; auto.

assert ( Config c t0 sigma_l_e = Config c t1_r s0_r).
apply simulation_H with t t1 (SIGMA s h) (SIGMA s0 h0) s h; auto. 
rewrite <- H4 in H3. auto.  

subst.  apply error_state_cannot_reach_valid_state in H_multistep_reduction. intuition. 
Qed. 

Lemma erasure_preserve_value : forall v sigma v' sigma' ct, 
  value v ->
  erasure (Config ct v sigma) (Config ct v' sigma') ->
  value v'.
Proof. 
  intros v sigma v' sigma' ct. intro Hv. intro Herasure.
  generalize dependent v'. induction Hv; intro v'; intro Herasure; inversion Herasure.
  apply v_oid. apply v_dot. apply v_null. apply v_dot. apply v_label. apply v_dot.
  subst. assert (value v'0). apply IHHv. auto. apply v_labeled.  auto. 
  apply v_dot.  assert (value v'0). subst. apply IHHv. auto. apply v_opa_labeled.  auto. apply v_dot.  
Qed. 

Inductive L_equivalence_config : config -> config -> Prop :=
  | L_equal_config : forall s h t ct, 
      L_equivalence_config (Config ct t (SIGMA s h))  (Config ct t (SIGMA s h))
  | L_equivalence_config_L : forall s h s' h' t t' lb1 lb2 ct, 
      lb1 = current_label (SIGMA s h) ->
      lb2 = current_label (SIGMA s' h') ->
      lb1 = lb2 ->
      flow_to lb2 L_Label = true ->
      L_equivalence_tm t h t' h'->
      L_equivalence_store s h s' h' ->
      L_equivalence_config (Config ct t (SIGMA s h)) (Config ct t' (SIGMA s' h'))
  | L_equivalence_config_H : forall s h s' h' t t' lb1 lb2 ct, 
      L_equivalence_store s h s' h' ->
      lb1 = current_label (SIGMA s h) ->
      lb2 = current_label (SIGMA s' h') ->
      flow_to lb1 L_Label = false ->
      flow_to lb2 L_Label = false ->
      L_equivalence_config (Config ct t (SIGMA s h)) (Config ct t' (SIGMA s' h')).






Lemma erasure_equal_imply_L_equivalence : forall ct v1 v2 s1 s2 h1 h2 v_r s_r h_r, 
      value v1 -> value v2 ->
      (erasure (Config ct v1 (SIGMA s1 h1)) (Config ct v_r (SIGMA s_r h_r))) ->
      (erasure (Config ct v2 (SIGMA s2 h2)) (Config ct v_r (SIGMA s_r h_r))) ->
      L_equivalence_config (Config ct v1 (SIGMA s1 h1)) (Config ct v2 (SIGMA s2 h2)).
Proof.
  intros  ct v1 v2 s1 s2 h1 h2 v_r s_r h_r. intro H_v1. intro H_v2. 
  intro H_erasure1.   intro H_erasure2.
  remember  (Config ct v1 (SIGMA s1 h1) ) as v1_config. 
  generalize dependent v2.      generalize dependent v1.
  induction H_erasure1; intros; inversion Heqv1_config; subst; try (inversion H_v1).
    -  inversion H_erasure2; subst; auto.
        inversion H_v2. apply L_equal_config. 
    - inversion H_v2; subst;  inversion H_erasure2; 
      try (subst; remember (current_label (SIGMA s1 h1))  as lb0; inversion H_erasure2; apply L_equivalence_config_H with lb0 lb0; auto;
          apply L_equivalence_equal_store).
    - inversion H_v2; subst;  inversion H_erasure2; 
      try (subst; remember (current_label (SIGMA s1 h1))  as lb0; inversion H_erasure2; apply L_equivalence_config_H with lb0 lb0; auto;
          apply L_equivalence_equal_store). apply L_equal_config.
    - inversion H_v2; subst;  inversion H_erasure2; 
      try (subst; remember (current_label (SIGMA s1 h1))  as lb0; inversion H_erasure2; apply L_equivalence_config_H with lb0 lb0; auto;
          apply L_equivalence_equal_store). 
    - inversion H_v2; subst;  inversion H_erasure2; 
      try (subst; remember (current_label (SIGMA s1 h1))  as lb0; inversion H_erasure2; apply L_equivalence_config_H with lb0 lb0; auto;
          apply L_equivalence_equal_store); try (apply L_equal_config).
    - inversion H_v2; subst;  inversion H_erasure2; 
      try (subst; remember (current_label (SIGMA s1 h1))  as lb0; inversion H_erasure2; apply L_equivalence_config_H with lb0 lb0; auto;
          apply L_equivalence_equal_store); try (apply L_equal_config); try (apply L_equivalence_config_H with cur_lbl cur_lbl; auto;
          apply L_equivalence_equal_store).
    - inversion H_v2; subst;  inversion H_erasure2; 
      try (subst; remember (current_label (SIGMA s1 h1))  as lb0; inversion H_erasure2; apply L_equivalence_config_H with lb0 lb0; auto;
          apply L_equivalence_equal_store); try (apply L_equal_config); try (apply L_equivalence_config_H with cur_lbl cur_lbl; auto;
          apply L_equivalence_equal_store). 
      subst. assert (L_equivalence_config (Config ct v (SIGMA s1 h1))
                 (Config ct v1 (SIGMA s1 h1))). apply IHH_erasure1 with v; auto.
      inversion H. apply L_equal_config.
      subst. remember (current_label (SIGMA s1 h1)) as cur_lb.
      apply L_equivalence_config_L with cur_lb cur_lb; auto.
      assert (flow_to lb L_Label = true \/ flow_to lb L_Label = false). 
      apply excluded_middle_label.
      destruct H2.       apply L_equivalence_tm_eq_v_l_L; auto.
      apply L_equivalence_tm_eq_v_l_H; auto.
    
      apply L_equivalence_config_H with lb1 lb2; auto.

    - inversion H_v2; subst;  inversion H_erasure2; 
      try (subst; remember (current_label (SIGMA s1 h1))  as lb0; inversion H_erasure2; apply L_equivalence_config_H with lb0 lb0; auto;
          apply L_equivalence_equal_store); try (apply L_equal_config); try (apply L_equivalence_config_H with cur_lbl cur_lbl; auto;
          apply L_equivalence_equal_store).
    - inversion H_v2; subst;  inversion H_erasure2.
      subst. assert (L_equivalence_config (Config ct v (SIGMA s1 h1))
                 (Config ct v1 (SIGMA s1 h1))). apply IHH_erasure1 with v; auto.
      inversion H. apply L_equal_config.
      subst. remember (current_label (SIGMA s1 h1)) as cur_lb.
      apply L_equivalence_config_L with cur_lb cur_lb; auto.
      assert (flow_to lb L_Label = true \/ flow_to lb L_Label = false). 
      apply excluded_middle_label.
      destruct H2.       apply L_equivalence_tm_eq_v_opa_l_L; auto.
      apply L_equivalence_tm_eq_v_opa_l_H; auto.
    
      apply L_equivalence_config_H with lb1 lb2; auto.
  -  inversion H_v2; subst;  inversion H_erasure2; 
      try (subst; remember (current_label (SIGMA s1 h1))  as lb0; inversion H_erasure2; apply L_equivalence_config_H with lb0 lb0; auto;
          apply L_equivalence_equal_store); try (apply L_equal_config); try (apply L_equivalence_config_H with cur_lbl cur_lbl; auto;
          apply L_equivalence_equal_store).
Qed.


Theorem Non_interference : forall ct t s s' h h' sf sf' lb x s0 s1 h1 s2 h2 v1 v2 final_v1 final_v2,
      field_wfe_heap ct h -> wfe_heap ct h -> wfe_stack ct h s->
      field_wfe_heap ct h' -> wfe_heap ct h' -> wfe_stack ct h' s'->
      s = cons (Labeled_frame lb sf) s0 ->
      s' = cons (Labeled_frame lb sf') s0 ->
      sf x = Some (v_l v1 H_Label) ->
      sf' x = Some (v_l v2 H_Label) ->
      L_equivalence_store s h s' h' ->
      (Config ct t (SIGMA s h)) ==>* (Config ct final_v1 (SIGMA s1 h1)) -> 
      (Config ct t (SIGMA s' h')) ==>* (Config ct final_v2 (SIGMA s2 h2)) ->
      value final_v1-> value final_v2 -> 
      forall T, has_type ct empty_context h t T -> has_type ct empty_context h' t T ->
      L_equivalence_config (Config ct final_v1 (SIGMA s1 h1)) (Config ct final_v2 (SIGMA s2 h2)).

Proof. 
    intros ct t s s' h h' sf sf' lb x s0 s1 h1 s2 h2 v1 v2 final_v1 final_v2.
    intro H_wfe_field. intro H_wfe_heap. intro H_wfe_stack. 
    intro H_wfe_field'. intro H_wfe_heap'. intro H_wfe_stack'. 
    intro H_stack1. intro H_stack2. intro H_high_v1. intro H_high_v2.
    intro H_equal_start.  intro H_execution1.  intro H_execution2. intro H_final_v1. intro H_final_v2.
    intro T. intro H_typing_h. intro H_typing_h'. 
    assert (exists t_r sigma_r, erasure (Config ct t (SIGMA s h)) (Config ct t_r sigma_r)).
    apply erasue_target.
    assert (exists t_r' sigma_r', erasure (Config ct t (SIGMA s' h')) (Config ct t_r' sigma_r')).
    apply erasue_target.
    destruct H as [t_r]. destruct H as [sigma_r]. 
    destruct H0 as [t_r']. destruct H0 as [sigma_r'].
    assert  ((Config ct t_r sigma_r) = (Config ct t_r' sigma_r')).
    apply erasure_equal_input with t s h s' h'; auto.

    assert (exists final_v1_r sigma1_r, erasure (Config ct final_v1 (SIGMA s1 h1)) (Config ct final_v1_r sigma1_r)).
    apply erasue_target. destruct H2 as [final_v1_r]. destruct H2 as [sigma1_r].
    assert ((Config ct t_r sigma_r) ==>L* (Config ct final_v1_r sigma1_r)).
    apply multi_step_simulation with t final_v1 (SIGMA s h) (SIGMA s1 h1) s h T; auto.

    assert (exists final_v2_r sigma2_r, erasure (Config ct final_v2 (SIGMA s2 h2)) (Config ct final_v2_r sigma2_r)).
    apply erasue_target. destruct H4 as [final_v2_r]. destruct H4 as [sigma2_r].
    assert ((Config ct t_r' sigma_r') ==>L* (Config ct final_v2_r sigma2_r)).
    apply multi_step_simulation with t final_v2 (SIGMA s' h') (SIGMA s2 h2) s' h' T; auto.

    rewrite H1 in H3.

    assert (final_v1_r = final_v2_r /\ sigma1_r = sigma2_r). 
    apply  L_reduction_multistep_determinacy with ct t_r' sigma_r'; auto. 
    apply erasure_preserve_value with final_v1 (SIGMA s1 h1) sigma1_r ct; auto.

    apply erasure_preserve_value with final_v2 (SIGMA s2 h2) sigma2_r ct; auto. 
    induction sigma1_r.     induction sigma2_r. 
    apply erasure_equal_imply_L_equivalence with final_v1_r s3 h0; auto. 
    destruct H6. subst. inversion H7. auto.
Qed.  

