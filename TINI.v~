
Require Import Coq.Arith.Arith.
Require Import Coq.Bool.Bool.
Require Import Coq.Strings.String.
Require Import Coq.Arith.EqNat.
Require Import Coq.omega.Omega.
Require Import Coq.Lists.List.

Require Import SfLib.
Require Import Language.
Require Import Lemmas.
Require Import Low_eq.
Require Import Label.




Lemma simulation_L : forall ct t1 fs1 lb1 sf1 ctns_stack1 h1  t2 fs2 lb2 sf2 ctns_stack2 h2
      ctn1' ctns_stack1' h1'  ctn2' ctns_stack2' h2' φ, 
      valid_config (Config ct (Container t1 fs1 lb1 sf1) ctns_stack1 h1 ) ->
      valid_config (Config ct (Container t2 fs2 lb2 sf2) ctns_stack2 h2 ) ->
      forall T, tm_has_type ct empty_context h1 t1 T -> 
      tm_has_type ct empty_context h2 t2 T -> 
      field_wfe_heap ct h1 -> wfe_heap ct h1 ->
      (*wfe_stack_frame ct h1 sf1 -> *)
      field_wfe_heap ct h2 -> wfe_heap ct h2 ->
      (* wfe_stack_frame ct h2 sf2 -> *)
      flow_to lb1 L_Label = true ->
      flow_to lb2 L_Label = true ->
      L_equivalence_config (Config ct (Container t1 fs1 lb1 sf1) ctns_stack1 h1 )
            (Config ct (Container t2 fs2 lb2 sf2) ctns_stack2 h2)  φ ->
     Config ct (Container t1 fs1 lb1 sf1) ctns_stack1 h1 
      ==> Config ct ctn1' ctns_stack1' h1' ->
     Config ct (Container t2 fs2 lb2 sf2) ctns_stack2 h2
      ==> Config ct ctn2' ctns_stack2' h2' ->
     L_equivalence_heap h1 h2 φ ->
      exists  φ', L_equivalence_config (Config ct ctn1' ctns_stack1' h1')
                                      (Config ct ctn2' ctns_stack2' h2')  φ'.
Proof. Admitted.

Lemma NI : forall ct t1 fs1 lb1 sf1 ctns_stack1 h1  t2 fs2 lb2 sf2 ctns_stack2 h2 lb1' sf1' lb2' sf2' final_v1  final_v2  h1' h2' φ, 
    valid_config (Config ct (Container t1 fs1 lb1 sf1) ctns_stack1 h1 ) ->
    valid_config (Config ct (Container t2 fs2 lb2 sf2) ctns_stack2 h2 ) ->
     Config ct (Container t1 fs1 lb1 sf1)  ctns_stack1 h1
            ==>* Config ct (Container final_v1 nil lb1' sf1') nil h1' ->
     Config ct (Container t2 fs2 lb2 sf2') ctns_stack2 h2 
            ==>* Config ct (Container final_v2 nil lb2' sf2') nil h2' ->
     L_equivalence_config (Config ct (Container t1 fs1 lb1 sf1) ctns_stack1 h1 )
            (Config ct (Container t2 fs2 lb2 sf2) ctns_stack2 h2)  φ ->
     value final_v1 -> value final_v2 ->
      forall T,
        config_has_type ct empty_context h1 (Config ct (Container t1 fs1 lb1 sf1)  ctns_stack1 h1) T ->
          config_has_type ct empty_context h2 (Config ct (Container t2 fs2 lb2 sf2)  ctns_stack2 h2) T ->
          L_equivalence_heap h1 h2 φ ->
      exists  φ', L_equivalence_config (Config ct (Container final_v1 nil lb1' sf1') nil h1')  (Config ct (Container final_v2 nil lb2' sf2') nil h2')  φ'.
Proof with eauto.
  intros  ct t1 fs1 lb1 sf1 ctns_stack1 h1  t2 fs2 lb2 sf2 ctns_stack2 h2 lb1' sf1' lb2' sf2' final_v1  final_v2  h1' h2' φ.
  intro H_valid1. intro H_valid2.
  intro H_execution1. intro H_execution2.
  intro H_low_eq. intro Hv_final1. intro Hv_final2.
  intro T. intro H_typing1. intro H_typing2.
  intro H_bijection.
  
      

Lemma Non_interference : forall ct x t fs lb sf sf' lb1 sf1  lb2 sf2 v1 v2 final_v1 final_v2 h1 h2, 
      valid_syntax t ->
      field_wfe_heap ct nil -> wfe_heap ct nil ->         
      wfe_stack_frame ct nil (Labeled_frame lb sf) ->
      field_wfe_heap ct nil -> wfe_heap ct nil ->         
      wfe_stack_frame ct nil (Labeled_frame lb sf') ->
      L_equivalence_store sf nil sf' nil -> 
      sf x = Some (v_l v1 H_Label) ->
      sf' x = Some (v_l v2 H_Label) ->
     Config ct (Container t fs lb sf) nil nil
      ==>* Config ct (Container final_v1 nil lb1 sf1) nil h1 ->
     Config ct (Container t fs lb sf') nil nil 
      ==>* Config ct (Container final_v2 nil lb2 sf2) nil h2 ->
      value final_v1 -> value final_v2 ->
      forall T, has_type ct empty_context nil t T->
      L_equivalence_config (Config ct (Container final_v1 nil lb1 sf1) nil h1) (Config ct (Container final_v2 nil lb2 sf2) nil h2).
Proof. 
intros  ct x t fs lb sf sf' lb1 sf1  lb2 sf2 v1 v2 final_v1 final_v2 h1 h2.
    intro H_valid_syntax.
    intro H_wfe_field. intro H_wfe_heap. intro H_wfe_frame. 
    intro H_wfe_field'. intro H_wfe_heap'. intro H_wfe_frame'. intro H_equal_input. 
    intro H_sf1. intro H_sf2.  intro H_execution1.  intro H_execution2. intro H_final_v1. intro H_final_v2.
    intro T. intro H_typing.
    remember (erasure (Config ct (Container t fs lb sf) nil nil)) as config_r.
    remember (erasure (Config ct (Container t fs lb sf') nil nil)) as config_r'.

    assert  (config_r = config_r'). subst. 
    apply erasure_equal_input. auto. subst.  

    assert ( (erasure (Config ct (Container t fs lb sf) nil nil))  ==>L* (erasure (Config ct (Container final_v1 nil lb1 sf1) nil h1) ) ).
    apply multi_step_simulation with T; auto.  

    assert ( (erasure (Config ct (Container t fs lb sf') nil nil))  ==>L* (erasure (Config ct (Container final_v2 nil lb2 sf2) nil h2) ) ).
    apply multi_step_simulation with T; auto.  


   assert ((erasure (Config ct (Container final_v1 nil lb1 sf1) nil h1) ) = (erasure (Config ct (Container final_v2 nil lb2 sf2) nil h2) ) ).
   (*apply L_reduction_multistep_determinacy.*) admit.

   unfold erasure in H2. unfold erasure_fun in H2. 
    case_eq (flow_to lb1 L_Label). intro. rewrite H3 in H2. 
    case_eq (flow_to lb2 L_Label). intro. rewrite H4 in H2. 
    apply L_equivalence_config_L; auto.  admit. admit. 

    intro. rewrite H4 in H2. inversion H2. rewrite H7 in H3. rewrite H3 in H4. inversion H4. 

    intro.  rewrite H3 in H2. 
    case_eq (flow_to lb2 L_Label). intro. rewrite H4 in H2.  inversion H2. 
    rewrite H7 in H3. rewrite H3 in H4. inversion H4. 

    intro. rewrite H4 in H2. apply L_equivalence_config_H; auto.
Qed. 

  